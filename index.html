<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Pixel Art Hiking Loop</title>
    <style>
        body, html {
            margin: 0;
            padding: 0;
            width: 100%;
            height: 100%;
            background-color: #000;
            overflow: hidden;
            font-family: sans-serif;
        }
        canvas {
            display: block;
            width: 100vw;
            height: 100vh;
            image-rendering: -moz-crisp-edges;
            image-rendering: -webkit-optimize-contrast;
            image-rendering: crisp-edges;
            image-rendering: pixelated;
        }
        #ui {
            position: absolute;
            top: 10px;
            left: 10px;
            color: rgba(255, 255, 255, 0.7);
            text-shadow: 1px 1px 0 #000;
            pointer-events: none;
            font-size: 14px;
            letter-spacing: 1px;
        }
        #sound-btn {
            position: absolute;
            top: 10px;
            right: 10px;
            background: rgba(0, 0, 0, 0.4);
            border: 1px solid rgba(255, 255, 255, 0.25);
            color: rgba(255, 255, 255, 0.8);
            font-size: 20px;
            width: 40px;
            height: 40px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: background 0.3s;
            z-index: 10;
        }
        #sound-btn:hover { background: rgba(0, 0, 0, 0.6); }
    </style>
</head>
<body>
    <div id="ui">A Scenic Walk...</div>
    <button id="sound-btn" title="Toggle sound">ðŸ”‡</button>
    <canvas id="game"></canvas>

    <script>
        const canvas = document.getElementById('game');
        const ctx = canvas.getContext('2d');

        const PIXEL_SCALE = 4;
        let cx = 0;
        let HORIZON = 0;

        let time = 0;
        let cameraZ = 0;
        const SPEED = 0.25;
        const FOV = 200;
        const CAMERA_Y = 60;
        const MAX_Z = 2500;

        let entities = [];
        let clouds = [];
        let mountains = { far: [], mid: [], near: [] };
        let birds = [];
        let sheeps = [];

        const PALETTE = {
            skyBands: ['#a9d3e9', '#cbe1d6', '#f2e8b9', '#efc68b', '#e0985c'],
            sun: '#ffc15e',
            cloudLight: '#fdf6e2',
            cloudBase: '#e3d2b8',
            cloudShadow: '#c4a787',

            hillFar: '#7a9a6e', hillFarLight: '#8dab7d', hillFarShadow: '#6a8860', hillFarTree: '#5c7a52',
            hillMid: '#6d8e4a', hillMidLight: '#7ea058', hillMidShadow: '#5a7a3c', hillMidTree: '#4a6830', hillMidField: '#8ba55c',
            hillNear: '#5e7e38', hillNearLight: '#72943e', hillNearShadow: '#4c6a2c', hillNearTree: '#3a5822', hillNearField: '#7d9c48', hillNearDark: '#3e5520',

            grassLight: '#94a161', grassDark: '#78854a', grassDarker: '#5c6934',
            grassShades: ['#6c7a38', '#5c6934', '#94a161', '#78854a', '#4b5726'],
            treeTrunk: '#443125', treeTrunkDark: '#241810',
            pineLeavesBase: ['#2b4a2e', '#325736', '#3b663f'],
            pineLeavesHigh: ['#3b663f', '#46784a', '#528c57'],
            pineLeavesShadow: ['#162618', '#1c301e', '#213823'],
            oakLeavesBase: ['#59662f', '#667536', '#75873e'],
            oakLeavesHigh: ['#75873e', '#869947', '#99ad52'],
            oakLeavesShadow: ['#333b1b', '#3d4720', '#485426'],
            oakLeafColors: ['#99ad52', '#869947', '#b5a142', '#d48d3d'],

            treeOutline: '#1e3318',
            treeShadowDrop: 'rgba(20, 35, 15, 0.3)',
            rimLight: '#c8d878',
            rimLightBright: '#dae89a',
            hazeColor: { r: 138, g: 171, b: 110 },

            horizonHaze: { r: 215, g: 205, b: 170 },
        };

        const HAZE_FAR = 0.45;
        const HAZE_MID = 0.22;
        const HAZE_NEAR = 0.08;

        function hexToRgb(hex) {
            return { r:parseInt(hex.slice(1,3),16), g:parseInt(hex.slice(3,5),16), b:parseInt(hex.slice(5,7),16) };
        }
        function rgbToHex(r,g,b) {
            return '#'+((1<<24)+(Math.round(Math.min(255,Math.max(0,r)))<<16)+(Math.round(Math.min(255,Math.max(0,g)))<<8)+Math.round(Math.min(255,Math.max(0,b)))).toString(16).slice(1);
        }
        function lerpColor(hex, hazeRgb, t) {
            let c = hexToRgb(hex);
            return rgbToHex(c.r+(hazeRgb.r-c.r)*t, c.g+(hazeRgb.g-c.g)*t, c.b+(hazeRgb.b-c.b)*t);
        }
        function haze(hex, amount) {
            return lerpColor(hex, PALETTE.horizonHaze, amount);
        }

        function resize() {
            canvas.width = Math.ceil(window.innerWidth/PIXEL_SCALE);
            canvas.height = Math.ceil(window.innerHeight/PIXEL_SCALE);
            cx = canvas.width/2;
            HORIZON = canvas.height*0.45;
            ctx.imageSmoothingEnabled = false;
            generateMountains();
        }

        function hash(n) { let x=Math.sin(n)*43758.5453; return x-Math.floor(x); }

        function generateMountains() {
            let cw = canvas.width;
            mountains.far = [
                { x:cw*0.15, w:cw*1.0, h:65+Math.random()*20, seed:Math.random()*999 },
                { x:cw*0.6, w:cw*1.3, h:80+Math.random()*20, seed:Math.random()*999 },
                { x:cw*1.05, w:cw*0.9, h:58+Math.random()*20, seed:Math.random()*999 },
            ];
            mountains.mid = [
                { x:cw*0.1, w:cw*1.1, h:50+Math.random()*15, seed:Math.random()*999 },
                { x:cw*0.55, w:cw*1.4, h:55+Math.random()*15, seed:Math.random()*999 },
                { x:cw*1.0, w:cw*1.0, h:45+Math.random()*15, seed:Math.random()*999 },
            ];
            mountains.near = [
                { x:cw*0.25, w:cw*1.5, h:35+Math.random()*12, seed:Math.random()*999 },
                { x:cw*0.85, w:cw*1.4, h:40+Math.random()*12, seed:Math.random()*999 },
            ];
            sheeps = [];
            for (let i=0; i<14; i++) {
                sheeps.push({ x:Math.random()*cw, y:HORIZON-8-Math.random()*20,
                    speed:(Math.random()>0.5?1:-1)*(0.00144+Math.random()*0.00288), offset:Math.random()*100 });
            }
        }

        function getHillY(m, px) {
            let t=(px-(m.x-m.w/2))/m.w;
            if (t<0||t>1) return HORIZON;
            return HORIZON - Math.sin(t*Math.PI)*m.h - Math.sin(t*Math.PI*4.5+m.seed)*m.h*0.08
                - Math.sin(t*Math.PI*7.2+m.seed*1.7)*m.h*0.04 - Math.sin(t*Math.PI*11.0+m.seed*2.3)*m.h*0.025;
        }

        function fillHillWithVerticalFade(m, baseColor, hazeAmount) {
            let left=Math.max(0,Math.floor(m.x-m.w/2)), right=Math.min(canvas.width,Math.ceil(m.x+m.w/2));
            let hazedBase = haze(baseColor, hazeAmount);
            ctx.fillStyle = hazedBase;
            ctx.beginPath(); ctx.moveTo(left, HORIZON);
            for (let px=left; px<=right; px++) ctx.lineTo(px, getHillY(m, px));
            ctx.lineTo(right, HORIZON); ctx.closePath(); ctx.fill();

            let minY = HORIZON;
            for (let px=left; px<=right; px+=4) { let y=getHillY(m,px); if(y<minY) minY=y; }
            let hillHeight = HORIZON - minY;
            if (hillHeight < 2) return;

            let extraFade = hazeAmount * 0.4;
            let hazedBottom = haze(baseColor, Math.min(0.85, hazeAmount + extraFade));
            let bottomRgb = hexToRgb(hazedBottom);
            let baseRgb = hexToRgb(hazedBase);

            let fadeStart = minY + hillHeight * 0.4;
            for (let y = Math.floor(fadeStart); y < HORIZON; y++) {
                let fadeT = (y - fadeStart) / (HORIZON - fadeStart);
                fadeT = fadeT * fadeT;
                let rowColor = rgbToHex(
                    baseRgb.r + (bottomRgb.r - baseRgb.r) * fadeT,
                    baseRgb.g + (bottomRgb.g - baseRgb.g) * fadeT,
                    baseRgb.b + (bottomRgb.b - baseRgb.b) * fadeT
                );
                ctx.fillStyle = rowColor;
                for (let px = left; px < right; px += 3) {
                    if (getHillY(m, px) <= y) {
                        ctx.fillRect(px, y, 3, 1);
                    }
                }
            }
        }

        function drawHillPatches(m, lightColor, shadowColor, fieldColor, hazeAmount) {
            let left=Math.max(0,Math.floor(m.x-m.w/2)), right=Math.min(canvas.width,Math.ceil(m.x+m.w/2));
            let hLight = haze(lightColor, hazeAmount);
            let hShadow = haze(shadowColor, hazeAmount);
            let hField = haze(fieldColor, hazeAmount);

            for (let px=left+2; px<right-2; px++) {
                let slope = getHillY(m,px+2)-getHillY(m,px);
                if (slope>0.3) { ctx.fillStyle=hShadow; ctx.fillRect(px, Math.round(getHillY(m,px)), 1, Math.round(HORIZON-getHillY(m,px))); }
                else if (slope<-0.3) { ctx.fillStyle=hLight; ctx.fillRect(px, Math.round(getHillY(m,px)), 1, Math.round(HORIZON-getHillY(m,px))); }
            }
            let np=3+Math.floor(hash(m.seed)*4);
            for (let i=0; i<np; i++) {
                let t=0.15+hash(m.seed+i*17)*0.7, px=m.x-m.w/2+t*m.w, pw=8+hash(m.seed+i*31)*25;
                let py=getHillY(m,px), ph=(HORIZON-py)*(0.2+hash(m.seed+i*7)*0.4);
                if (px>0&&px+pw<canvas.width) { ctx.fillStyle=hField; ctx.fillRect(Math.round(px),Math.round(py+(HORIZON-py)*0.2),Math.round(pw),Math.round(ph)); }
            }
        }

        function drawTreeLine(m, treeColor, density, maxTreeH, hazeAmount) {
            let left=Math.max(0,Math.floor(m.x-m.w/2)), right=Math.min(canvas.width,Math.ceil(m.x+m.w/2));
            ctx.fillStyle = haze(treeColor, hazeAmount);
            for (let px=left; px<right; px+=2) {
                let y=getHillY(m,px); if (y>=HORIZON-2) continue;
                if (hash(px*0.37+m.seed*1.1)>density) continue;
                let treeH=2+hash(px*0.53+m.seed)*maxTreeH, treeW=1+Math.floor(hash(px*0.71+m.seed)*2);
                let ty=Math.round(y);
                ctx.fillRect(px, ty-treeH, treeW, treeH);
                if (treeH>3) ctx.fillRect(px-1, ty-treeH, treeW+1, Math.round(treeH*0.4));
            }
        }

        function drawHedgeRow(m, color, hazeAmount) {
            let left=Math.max(0,Math.floor(m.x-m.w/2)), right=Math.min(canvas.width,Math.ceil(m.x+m.w/2));
            let band=0.3+hash(m.seed*3.7)*0.3;
            ctx.fillStyle = haze(color, hazeAmount);
            for (let px=left; px<right; px++) {
                let topY=getHillY(m,px), bandY=topY+(HORIZON-topY)*band;
                if (bandY<HORIZON-1) { ctx.fillRect(px, Math.round(bandY), 1, 1);
                    if (hash(px*0.19+m.seed)>0.6) ctx.fillRect(px, Math.round(bandY)-1, 1, 1); }
            }
        }

        // Stratified tree placement: alternates left/right, varied distances from center
        function getStratifiedTreeX(index, total) {
            let isLeft = (index % 2 === 0);
            // Within each side, spread trees across range 350-1250
            let sideIndex = Math.floor(index / 2);
            let sideTotal = Math.ceil(total / 2);
            // Use golden ratio spacing for natural-looking but even distribution
            let t = (sideIndex + 0.3 + Math.random() * 0.4) / sideTotal;
            let dist = 350 + t * 900; // Range 350 to 1250
            return isLeft ? -dist : dist;
        }

        function getGrassVariant(x,z) {
            let noise=Math.sin(x*0.002)+Math.cos(z*0.002)+Math.sin((x+z)*0.003);
            if (noise>1.2) return 8+Math.floor(Math.random()*2);
            return Math.floor(Math.random()*8);
        }

        function resetLeaf(leaf) {
            let trees=entities.filter(e=>e.type==='tree');
            if (!trees.length) return;
            let tree=trees[Math.floor(Math.random()*trees.length)];
            let isPine=(tree.variant%2===0);
            leaf.x=tree.x+(Math.random()-0.5)*120; leaf.z=tree.z+(Math.random()-0.5)*40;
            leaf.y=-30-Math.random()*80; leaf.speedY=0.03+Math.random()*0.06;
            leaf.treeType=isPine?0:1;
            let colors=isPine?PALETTE.pineLeavesHigh:PALETTE.oakLeafColors;
            leaf.color=colors[Math.floor(Math.random()*colors.length)];
        }

        // Respawn tree with stratified left/right placement
        function respawnTreeX() {
            // Count current left vs right trees to maintain balance
            let leftCount = 0, rightCount = 0;
            entities.forEach(e => {
                if (e.type === 'tree') {
                    if (e.x < 0) leftCount++; else rightCount++;
                }
            });
            let isLeft = leftCount <= rightCount;
            let dist = 350 + Math.random() * 900;
            return isLeft ? -dist : dist;
        }

        function init() {
            resize(); window.addEventListener('resize', resize);
            const TREE_COUNT = 20;
            for (let i=0; i<TREE_COUNT; i++) {
                entities.push({
                    type:'tree',
                    x: getStratifiedTreeX(i, TREE_COUNT),
                    y:CAMERA_Y,
                    z: (i / TREE_COUNT) * MAX_Z + Math.random() * (MAX_Z / TREE_COUNT), // stratified Z too
                    variant:Math.floor(Math.random()*6),
                    hScale:0.8+Math.random()*0.7
                });
            }
            for (let i=0; i<300; i++) {
                let gx=(Math.random()-0.5)*2000, gz=Math.random()*MAX_Z;
                entities.push({ type:'grass', x:gx, y:CAMERA_Y, z:gz, variant:getGrassVariant(gx,gz) });
            }
            for (let i=0; i<80; i++) {
                let leaf={type:'leaf'}; resetLeaf(leaf); leaf.y+=Math.random()*100; entities.push(leaf);
            }
            for (let i=0; i<6; i++) {
                clouds.push({ x:Math.random()*canvas.width, y:Math.random()*(HORIZON-50), w:40+Math.random()*80, h:15+Math.random()*20, speed:0.02+Math.random()*0.03 });
            }
            for (let i=0; i<5; i++) {
                birds.push({ x:Math.random()*canvas.width, y:10+Math.random()*(HORIZON/2), offset:Math.random()*100 });
            }
            requestAnimationFrame(loop);
        }

        function drawRect(x,y,w,h,color) { ctx.fillStyle=color; ctx.fillRect(Math.round(x),Math.round(y),Math.round(w),Math.round(h)); }

        function drawBackground() {
            let bandH=HORIZON/PALETTE.skyBands.length;
            PALETTE.skyBands.forEach((color,i)=>{ drawRect(0,i*bandH,canvas.width,bandH+2,color); });
            drawRect(canvas.width*0.75, HORIZON*0.15, 28, 28, PALETTE.sun);
            drawRect(canvas.width*0.75-2, HORIZON*0.15+4, 32, 20, PALETTE.sun);
            drawRect(canvas.width*0.75+4, HORIZON*0.15-2, 20, 32, PALETTE.sun);

            clouds.forEach(c => {
                c.x+=c.speed; if (c.x>canvas.width+c.w) c.x=-c.w;
                drawRect(c.x+c.w*0.05,c.y+c.h*0.4,c.w*0.9,c.h*0.7,PALETTE.cloudShadow);
                drawRect(c.x,c.y,c.w,c.h,PALETTE.cloudBase);
                drawRect(c.x+c.w*0.15,c.y-c.h*0.3,c.w*0.5,c.h*0.8,PALETTE.cloudBase);
                drawRect(c.x+c.w*0.4,c.y-c.h*0.5,c.w*0.4,c.h*1.1,PALETTE.cloudBase);
                drawRect(c.x+2,c.y+2,c.w*0.9,c.h*0.3,PALETTE.cloudLight);
                drawRect(c.x+c.w*0.15+2,c.y-c.h*0.3+2,c.w*0.4,c.h*0.3,PALETTE.cloudLight);
                drawRect(c.x+c.w*0.4+2,c.y-c.h*0.5+2,c.w*0.3,c.h*0.3,PALETTE.cloudLight);
            });

            // FAR HILLS
            mountains.far.forEach(m => {
                fillHillWithVerticalFade(m, PALETTE.hillFar, HAZE_FAR);
                drawHillPatches(m, PALETTE.hillFarLight, PALETTE.hillFarShadow, PALETTE.hillFarLight, HAZE_FAR);
                drawTreeLine(m, PALETTE.hillFarTree, 0.55, 3, HAZE_FAR);
            });

            // MID HILLS
            mountains.mid.forEach(m => {
                fillHillWithVerticalFade(m, PALETTE.hillMid, HAZE_MID);
                drawHillPatches(m, PALETTE.hillMidLight, PALETTE.hillMidShadow, PALETTE.hillMidField, HAZE_MID);
                drawHedgeRow(m, PALETTE.hillMidShadow, HAZE_MID);
                drawTreeLine(m, PALETTE.hillMidTree, 0.45, 4, HAZE_MID);
            });

            // NEAR HILLS
            mountains.near.forEach(m => {
                fillHillWithVerticalFade(m, PALETTE.hillNear, HAZE_NEAR);
                drawHillPatches(m, PALETTE.hillNearLight, PALETTE.hillNearShadow, PALETTE.hillNearField, HAZE_NEAR);
                drawHedgeRow(m, PALETTE.hillNearDark, HAZE_NEAR);
                drawTreeLine(m, PALETTE.hillNearTree, 0.35, 5, HAZE_NEAR);
            });

            // HORIZON HAZE BAND
            let hazeHex = rgbToHex(PALETTE.horizonHaze.r, PALETTE.horizonHaze.g, PALETTE.horizonHaze.b);
            let hazeBandH = 8;
            for (let i = 0; i < hazeBandH; i++) {
                let t = 1.0 - (i / hazeBandH);
                t = t * t * 0.3;
                ctx.globalAlpha = t;
                ctx.fillStyle = hazeHex;
                ctx.fillRect(0, HORIZON - hazeBandH + i, canvas.width, 1);
            }
            ctx.globalAlpha = 1.0;

            // Sheep
            sheeps.forEach(s => {
                s.x+=s.speed; if (s.x>canvas.width+10) s.x=-10; if (s.x<-10) s.x=canvas.width+10;
                let isEating=Math.sin(time*0.002+s.offset)>0.6;
                let sx=Math.round(s.x), sy=Math.round(s.y);
                ctx.fillStyle=PALETTE.cloudLight; ctx.fillRect(sx,sy,3,2); ctx.fillRect(sx+1,sy-1,1,1);
                ctx.fillStyle=PALETTE.treeTrunkDark; ctx.fillRect(sx,sy+2,1,1); ctx.fillRect(sx+2,sy+2,1,1);
                ctx.fillRect(s.speed>0?sx+3:sx-1, sy+(isEating?1:0), 1, 1);
            });

            birds.forEach(b => {
                b.x+=0.15; b.y+=Math.sin(time*0.0015+b.offset)*0.1; if (b.x>canvas.width+20) b.x=-20;
                ctx.fillStyle='#2c3e50';
                ctx.fillRect(Math.round(b.x),Math.round(b.y),2,1);
                ctx.fillRect(Math.round(b.x-2),Math.round(b.y-2),2,2);
                ctx.fillRect(Math.round(b.x+2),Math.round(b.y-2),2,2);
            });
        }

        function drawGround() {
            let startY=Math.floor(HORIZON)+1;
            ctx.fillStyle=PALETTE.grassLight; ctx.fillRect(0,startY,canvas.width,canvas.height-startY);
            for (let y=startY; y<canvas.height; y++) {
                let z=(FOV*CAMERA_Y)/(y-HORIZON); if (z>MAX_Z) continue;
                let scale=FOV/(FOV+z), actualZ=z+cameraZ, zIndex=Math.floor(actualZ/15);
                ctx.fillStyle=PALETTE.grassDark;
                let ns=3+(Math.abs(Math.sin(zIndex*0.77))*6);
                for(let i=0;i<ns;i++) { let hx=Math.sin(zIndex*0.11+i*1.5)*10000, wx=(Math.abs(hx)%6000)-3000;
                    ctx.fillRect(cx+wx*scale,y,(150+(Math.abs(Math.cos(zIndex+i))*250))*scale,1); }
                ctx.fillStyle=PALETTE.grassDarker;
                let nd=2+(Math.abs(Math.cos(zIndex*1.3))*4);
                for(let i=0;i<nd;i++) { let hx=Math.cos(zIndex*0.23+i*2.1)*10000, wx=(Math.abs(hx)%6000)-3000;
                    ctx.fillRect(cx+wx*scale,y,(80+(Math.abs(Math.sin(zIndex-i))*150))*scale,1); }
            }
        }

        function drawGrass(sx,sy,scale,variant) {
            let isTall=variant>=8, w=(isTall?5:3+(variant%3))*scale, h=(isTall?20+(variant%2)*10:8+(variant%4)*2)*scale;
            let col=PALETTE.grassShades[variant%PALETTE.grassShades.length], darkCol=PALETTE.grassShades[(variant+2)%PALETTE.grassShades.length];
            drawRect(sx-w/2,sy-h,w,h,darkCol); drawRect(sx-w/4,sy-h*0.8,w/2,h*0.8,col);
            if (isTall) { drawRect(sx-w,sy-h*0.9,2*scale,h*0.7,darkCol); drawRect(sx+w*0.5,sy-h*1.1,2*scale,h*0.8,col); drawRect(sx+w*0.5+2*scale,sy-h*1.1,3*scale,2*scale,col); }
            else { drawRect(sx+w/4,sy-h*1.2,1.5*scale,h*0.6,col); }
        }

        function getTreeHazeFactor(relZ) { return Math.max(0, Math.min(1, relZ/MAX_Z))*0.4; }

        function getPineBlocks(sx,sy,scale,wind,trunkH,variant) {
            let blocks=[], tiers=4+(variant%2);
            for (let i=0; i<tiers; i++) {
                let tw=(70-i*15)*scale, th=28*scale, ty=sy-trunkH+(5-i*20)*scale, wo=wind*(0.2+i*0.15);
                blocks.push({x:sx-tw/2+wo,y:ty,w:tw,h:th});
                blocks.push({x:sx-tw/2+wo-2*scale,y:ty+th*0.3,w:2*scale,h:th*0.7});
                blocks.push({x:sx+tw/2+wo,y:ty+th*0.3,w:2*scale,h:th*0.7});
                blocks.push({x:sx-tw/2+wo-5*scale,y:ty+th*0.5,w:3*scale,h:th*0.4});
                blocks.push({x:sx+tw/2+wo+2*scale,y:ty+th*0.5,w:3*scale,h:th*0.4});
            }
            return blocks;
        }

        function getOakBlocks(sx,sy,scale,wind,trunkH) {
            let cy=sy-trunkH-20*scale, wo=wind*0.4;
            return [{x:0,y:0,w:90,h:70},{x:-25,y:-10,w:60,h:50},{x:25,y:-10,w:60,h:50},
                {x:0,y:-30,w:70,h:50},{x:-35,y:15,w:40,h:40},{x:35,y:15,w:40,h:40},
                {x:-40,y:-20,w:25,h:25},{x:40,y:-20,w:25,h:25},{x:-20,y:-45,w:30,h:25},
                {x:20,y:-45,w:30,h:25},{x:-45,y:5,w:20,h:20},{x:45,y:5,w:20,h:20}
            ].map(b=>({ x:sx+b.x*scale+wo-(b.w*scale)/2, y:cy+b.y*scale, w:b.w*scale, h:b.h*scale }));
        }

        function drawTree(sx,sy,scale,origX,origZ,variant,hScale,relZ) {
            scale*=1.8*hScale;
            let wind=Math.sin(time*0.001+origX*0.1+origZ*0.05)*6*scale;
            let trunkW=Math.max(3,16*scale), trunkH=(90+(Math.abs(Math.round(origX))%40))*scale;
            let isPine=(variant%2===0);
            let hazeFactor=getTreeHazeFactor(relZ), hazeRgb=PALETTE.hazeColor;
            let canopyBlocks=isPine ? getPineBlocks(sx,sy,scale,wind,trunkH,variant) : getOakBlocks(sx,sy,scale,wind,trunkH);

            let outlinePad=Math.max(1,Math.round(2*scale));
            let shadowOffX=Math.max(1,Math.round(3*scale));
            let shadowOffY=Math.max(1,Math.round(3*scale));
            let rimWidth=Math.max(1,Math.round(1.5*scale));

            ctx.fillStyle=PALETTE.treeShadowDrop;
            canopyBlocks.forEach(b=>{ ctx.fillRect(Math.round(b.x+shadowOffX),Math.round(b.y+shadowOffY),Math.round(b.w),Math.round(b.h)); });

            let outlineColor=hazeFactor>0?lerpColor(PALETTE.treeOutline,hazeRgb,hazeFactor*0.8):PALETTE.treeOutline;
            ctx.fillStyle=outlineColor;
            canopyBlocks.forEach(b=>{ ctx.fillRect(Math.round(b.x-outlinePad),Math.round(b.y-outlinePad),Math.round(b.w+outlinePad*2),Math.round(b.h+outlinePad*2)); });

            let trunkCol=hazeFactor>0?lerpColor(PALETTE.treeTrunk,hazeRgb,hazeFactor):PALETTE.treeTrunk;
            let trunkDarkCol=hazeFactor>0?lerpColor(PALETTE.treeTrunkDark,hazeRgb,hazeFactor):PALETTE.treeTrunkDark;
            drawRect(sx-trunkW/2,sy-trunkH,trunkW/2,trunkH,trunkDarkCol);
            drawRect(sx,sy-trunkH,trunkW/2,trunkH,trunkCol);
            drawRect(sx-trunkW*0.2,sy-trunkH*0.8,2*scale,trunkH*0.6,trunkDarkCol);

            if (isPine) {
                let tiers=4+(variant%2);
                for (let i=0; i<tiers; i++) {
                    let tw=(70-i*15)*scale, th=28*scale, ty=sy-trunkH+(5-i*20)*scale, wo=wind*(0.2+i*0.15);
                    let bc=lerpColor(PALETTE.pineLeavesBase[i%3],hazeRgb,hazeFactor);
                    let hc=lerpColor(PALETTE.pineLeavesHigh[i%3],hazeRgb,hazeFactor);
                    let sc=lerpColor(PALETTE.pineLeavesShadow[i%3],hazeRgb,hazeFactor);
                    drawRect(sx-tw/2+wo,ty+th*0.4,tw,th*0.6,sc);
                    drawRect(sx-tw/2+wo,ty,tw/2,th*0.8,bc);
                    drawRect(sx+wo,ty,tw/2,th*0.8,hc);
                    drawRect(sx-tw/2+wo-2*scale,ty+th*0.3,2*scale,th*0.7,bc);
                    drawRect(sx+tw/2+wo,ty+th*0.3,2*scale,th*0.7,hc);
                    drawRect(sx-tw/2+wo-5*scale,ty+th*0.5,3*scale,th*0.4,bc);
                    drawRect(sx+tw/2+wo+2*scale,ty+th*0.5,3*scale,th*0.4,hc);
                    drawRect(sx-tw/3+wo,ty+th,6*scale,4*scale,sc);
                    drawRect(sx+tw/4+wo,ty+th,6*scale,4*scale,sc);
                }
            } else {
                let cy=sy-trunkH-20*scale, wo=wind*0.4;
                [{x:0,y:0,w:90,h:70},{x:-25,y:-10,w:60,h:50},{x:25,y:-10,w:60,h:50},
                 {x:0,y:-30,w:70,h:50},{x:-35,y:15,w:40,h:40},{x:35,y:15,w:40,h:40},
                 {x:-40,y:-20,w:25,h:25},{x:40,y:-20,w:25,h:25},{x:-20,y:-45,w:30,h:25},
                 {x:20,y:-45,w:30,h:25},{x:-45,y:5,w:20,h:20},{x:45,y:5,w:20,h:20}
                ].forEach(b => {
                    let bw=b.w*scale, bh=b.h*scale, bx=sx+b.x*scale+wo, by=cy+b.y*scale;
                    let bc=lerpColor(PALETTE.oakLeavesBase[variant%3],hazeRgb,hazeFactor);
                    let hc=lerpColor(PALETTE.oakLeavesHigh[variant%3],hazeRgb,hazeFactor);
                    let sc=lerpColor(PALETTE.oakLeavesShadow[variant%3],hazeRgb,hazeFactor);
                    drawRect(bx-bw/2,by+bh*0.2,bw,bh*0.8,sc);
                    drawRect(bx-bw/2,by,bw/2,bh*0.7,bc);
                    drawRect(bx,by,bw/2,bh*0.7,hc);
                    drawRect(bx-bw/2-2*scale,by+bh*0.2,2*scale,bh*0.5,bc);
                    drawRect(bx+bw/2,by+bh*0.2,2*scale,bh*0.5,hc);
                });
            }

            let rimColor=lerpColor(PALETTE.rimLight,hazeRgb,hazeFactor*0.5);
            let rimBright=lerpColor(PALETTE.rimLightBright,hazeRgb,hazeFactor*0.5);
            ctx.globalAlpha=Math.max(0.15, 1.0-hazeFactor*1.5);
            canopyBlocks.forEach(b => {
                drawRect(b.x+b.w-rimWidth, b.y, rimWidth, b.h, rimColor);
                drawRect(b.x, b.y, b.w, rimWidth, rimColor);
                drawRect(b.x+b.w-rimWidth*2, b.y, rimWidth*2, rimWidth, rimBright);
            });
            ctx.globalAlpha=1.0;
        }

        function drawLeaf(sx,sy,scale,leaf) {
            let w=Math.max(1,(leaf.treeType===0?1.5:3)*scale), h=Math.max(1,(leaf.treeType===0?4:3)*scale);
            drawRect(sx,sy,w,h,leaf.color);
        }

        function drawDog(charX,charY,charScale,walkPhase) {
            let bob=Math.abs(Math.sin(walkPhase*1.4))*2.5, legSwing=Math.sin(walkPhase*1.4);
            let dogX=charX+18*charScale, dogY=charY-2*charScale;
            let d=(x,y,w,h,color)=>{ drawRect(dogX+x*charScale,dogY+y*charScale-bob,w*charScale,h*charScale,color); };

            ctx.fillStyle='rgba(0,0,0,0.25)';
            ctx.fillRect(Math.round(dogX-4*charScale),Math.round(dogY+12*charScale),Math.round(10*charScale),Math.round(3*charScale));

            let tailWag=Math.sin(time*0.015)*3;
            d(-1+tailWag,8,2,4,'#A0693E'); d(-1.5+tailWag*1.3,11,2,3,'#B8804A'); d(-2+tailWag*1.5,13,2,2,'#D4C4A8');

            let lbl=legSwing>0?-legSwing*2.5:0, rbl=legSwing<0?legSwing*2.5:0;
            drawRect(dogX-4*charScale,dogY+(6+lbl)*charScale-bob,3*charScale,(5-lbl)*charScale,'#7A4E2D');
            drawRect(dogX+2*charScale,dogY+(6+rbl)*charScale-bob,3*charScale,(5-rbl)*charScale,'#8B5E3C');
            d(-4,10.5,3,1,'#D4C4A8'); d(2,10.5,3,1,'#D4C4A8');

            d(-4,0,10,8,'#A0693E'); d(-3,-1,8,2,'#B8804A'); d(-4,7,10,1,'#7A4E2D');
            d(-2,1,6,2,'#B8804A'); d(-1,3,4,2,'#A0693E');

            let lfl=legSwing<0?legSwing*2.5:0, rfl=legSwing>0?-legSwing*2.5:0;
            drawRect(dogX-4*charScale,dogY+(-3+lfl)*charScale-bob,2*charScale,(4-lfl)*charScale,'#7A4E2D');
            drawRect(dogX+4*charScale,dogY+(-3+rfl)*charScale-bob,2*charScale,(4-rfl)*charScale,'#8B5E3C');

            let headLook=Math.sin(time*0.0018), isLooking=Math.abs(headLook)>0.7, lookOffset=isLooking?headLook*2.5:0;
            d(-3+lookOffset,-7,8,5,'#A0693E'); d(-2+lookOffset,-8,6,3,'#B8804A'); d(-1+lookOffset,-6,4,3,'#A0693E');
            let earBounce=Math.sin(walkPhase*1.4)*0.5;
            d(-5+lookOffset,-7+earBounce,3,4,'#7A4E2D'); d(-5+lookOffset,-6+earBounce,2,2,'#6B3F22');
            d(4+lookOffset,-7+earBounce,3,4,'#7A4E2D'); d(5+lookOffset,-6+earBounce,2,2,'#6B3F22');
            if (isLooking) {
                if (headLook>0) { d(5+lookOffset,-5,2,2,'#B8804A'); d(6+lookOffset,-5,1,1,'#3D2517'); d(4+lookOffset,-7,1,1,'#1A0E08'); }
                else { d(-5+lookOffset,-5,2,2,'#B8804A'); d(-5+lookOffset,-5,1,1,'#3D2517'); d(-3+lookOffset,-7,1,1,'#1A0E08'); }
            }
            d(-3+lookOffset,-3,8,1,'#CC3333'); d(1+lookOffset,-3,1,2,'#FFD700');
        }

        function drawCharacter() {
            let charX=cx, charY=canvas.height-20, charScale=1.2;
            let walkPhase=time*0.0056925, bob=Math.abs(Math.sin(walkPhase))*4, legSwing=Math.sin(walkPhase);
            let p=(x,y,w,h,color)=>{ drawRect(charX+x*charScale,charY+y*charScale-bob,w*charScale,h*charScale,color); };

            ctx.fillStyle='rgba(0,0,0,0.3)';
            ctx.fillRect(Math.round(charX-12*charScale),Math.round(charY+12*charScale),Math.round(24*charScale),Math.round(4*charScale));

            let llY=legSwing>0?-legSwing*5:0;
            drawRect(charX-6*charScale,charY+5*charScale-bob-llY,5*charScale,(10+llY)*charScale,'#1E3D59');
            let rlY=legSwing<0?legSwing*5:0;
            drawRect(charX+1*charScale,charY+5*charScale-bob-rlY,5*charScale,(10+rlY)*charScale,'#1E3D59');

            p(-9,-12,18,18,'#6B4226'); p(-8,-11,16,16,'#8B5A3C'); p(-7,-10,14,14,'#7A4C30');
            p(-1,-9,2,12,'#5A3520'); p(-9,-14,18,3,'#5A3520'); p(-8,-13,16,1,'#6B4226');
            p(-9,6,18,2,'#5A3520'); p(-9,-4,18,1,'#5A3520'); p(-9,1,18,1,'#5A3520');
            p(-6,-3,12,6,'#7A4C30'); p(-5,-2,10,4,'#8B5A3C'); p(-5,-3,10,1,'#5A3520');
            p(-11,-2,3,7,'#6B4226'); p(8,-2,3,7,'#6B4226');
            p(8,-4,3,5,'#4A7A8C'); p(8,-5,3,2,'#5A8A9C');
            p(-10,-18,20,4,'#3D6B4F'); p(-9,-17,18,2,'#4D7B5F'); p(-10,-18,20,1,'#2D5B3F');
            p(-7,-18,2,4,'#5A3520'); p(5,-18,2,4,'#5A3520');
            p(-9,-12,3,14,'#5A3520'); p(6,-12,3,14,'#5A3520');
            p(-8,-11,1,12,'#6B4226'); p(8,-11,1,12,'#6B4226');

            p(-5,-24,10,10,'#f5cba7'); p(-6,-26,12,8,'#2c1e16');
            p(-5,-25,10,6,'#3a2920'); p(-4,-24,8,4,'#2c1e16');
            p(-7,-22,2,3,'#f5cba7'); p(5,-22,2,3,'#f5cba7');

            let laY=legSwing*4;
            drawRect(charX-12*charScale,charY-8*charScale-bob+laY,3*charScale,10*charScale,'#d35400');
            let raY=-legSwing*4;
            drawRect(charX+9*charScale,charY-8*charScale-bob+raY,3*charScale,10*charScale,'#d35400');

            drawDog(charX,charY,charScale,walkPhase);
        }

        function loop(timestamp) {
            time+=3; cameraZ+=SPEED;
            entities.forEach(e => {
                if (e.type==='leaf') { e.y+=e.speedY; e.x+=Math.sin(time*0.001+e.z)*0.5; }
                let relZ=e.z-cameraZ;
                if (relZ<1||(e.type==='leaf'&&e.y>CAMERA_Y)) {
                    if (e.type==='tree') { e.z+=MAX_Z; e.x=respawnTreeX(); e.hScale=0.8+Math.random()*0.7; }
                    else if (e.type==='grass') { e.z+=MAX_Z; e.x=(Math.random()-0.5)*2000; e.variant=getGrassVariant(e.x,e.z); }
                    else if (e.type==='leaf') { resetLeaf(e); relZ=e.z-cameraZ; }
                }
                e.relZ=relZ;
            });
            entities.sort((a,b)=>b.relZ-a.relZ);
            ctx.clearRect(0,0,canvas.width,canvas.height);
            drawBackground(); drawGround();
            entities.forEach(e => {
                if (e.relZ>MAX_Z) return;
                let scale=FOV/(FOV+e.relZ), sx=cx+e.x*scale, sy=HORIZON+(e.y!==undefined?e.y:CAMERA_Y)*scale;
                if (e.type==='tree') drawTree(sx,sy,scale,e.x,e.z,e.variant,e.hScale,e.relZ);
                if (e.type==='leaf') drawLeaf(sx,sy,scale,e);
                if (e.type==='grass') drawGrass(sx,sy,scale,e.variant);
            });
            drawCharacter();
            requestAnimationFrame(loop);
        }

        // === AMBIENT SOUND SYSTEM ===
        const Sound = {
            ctx: null,
            master: null,
            active: false,
            initialized: false,

            async init() {
                if (this.initialized) return;
                this.ctx = new (window.AudioContext || window.webkitAudioContext)();
                this.master = this.ctx.createGain();
                this.master.gain.value = 0;
                this.master.connect(this.ctx.destination);
                this.initialized = true;

                this.createWind();
                this.createLeaves();
                await this.loadBirds();
                await this.loadSheep();
            },

            async toggle() {
                if (!this.initialized) await this.init();
                if (this.ctx.state === 'suspended') await this.ctx.resume();

                this.active = !this.active;
                this.master.gain.linearRampToValueAtTime(
                    this.active ? 1.0 : 0, this.ctx.currentTime + 0.8
                );
                document.getElementById('sound-btn').textContent = this.active ? 'ðŸ”Š' : 'ðŸ”‡';
            },

            createWind() {
                const sr = this.ctx.sampleRate;
                const buf = this.ctx.createBuffer(1, 2 * sr, sr);
                const data = buf.getChannelData(0);
                let last = 0;
                for (let i = 0; i < data.length; i++) {
                    const white = Math.random() * 2 - 1;
                    data[i] = (last + 0.02 * white) / 1.02;
                    last = data[i];
                    data[i] *= 3.5;
                }
                const src = this.ctx.createBufferSource();
                src.buffer = buf;
                src.loop = true;

                const filter = this.ctx.createBiquadFilter();
                filter.type = 'lowpass';
                filter.frequency.value = 350;

                // Slow LFO to gently vary wind intensity
                const lfo = this.ctx.createOscillator();
                const lfoGain = this.ctx.createGain();
                lfo.type = 'sine';
                lfo.frequency.value = 0.12;
                lfoGain.gain.value = 80;
                lfo.connect(lfoGain);
                lfoGain.connect(filter.frequency);
                lfo.start();

                const gain = this.ctx.createGain();
                gain.gain.value = 0.12;

                src.connect(filter);
                filter.connect(gain);
                gain.connect(this.master);
                src.start();
            },

            createLeaves() {
                const sr = this.ctx.sampleRate;
                const buf = this.ctx.createBuffer(1, 2 * sr, sr);
                const data = buf.getChannelData(0);
                let b0=0,b1=0,b2=0,b3=0,b4=0,b5=0,b6=0;
                for (let i = 0; i < data.length; i++) {
                    const w = Math.random() * 2 - 1;
                    b0=0.99886*b0+w*0.0555179;
                    b1=0.99332*b1+w*0.0750759;
                    b2=0.96900*b2+w*0.1538520;
                    b3=0.86650*b3+w*0.3104856;
                    b4=0.55000*b4+w*0.5329522;
                    b5=-0.7616*b5-w*0.0168980;
                    data[i]=(b0+b1+b2+b3+b4+b5+b6+w*0.5362)*0.11;
                    b6=w*0.115926;
                }
                const src = this.ctx.createBufferSource();
                src.buffer = buf;
                src.loop = true;

                const bp = this.ctx.createBiquadFilter();
                bp.type = 'bandpass';
                bp.frequency.value = 2200;
                bp.Q.value = 0.5;

                // Amplitude modulation for gusting effect
                const lfo = this.ctx.createOscillator();
                const lfoGain = this.ctx.createGain();
                lfo.frequency.value = 0.25;
                lfoGain.gain.value = 0.03;
                lfo.connect(lfoGain);

                const gain = this.ctx.createGain();
                gain.gain.value = 0.06;
                lfoGain.connect(gain.gain);

                src.connect(bp);
                bp.connect(gain);
                gain.connect(this.master);
                lfo.start();
                src.start();
            },

            async loadBirds() {
                try {
                    const resp = await fetch('https://cdn.jsdelivr.net/gh/abetusk/noixer@master/assets/517042__sonidosreales245__forestday-bw-66.mp3');
                    const arr = await resp.arrayBuffer();
                    const buf = await this.ctx.decodeAudioData(arr);
                    const src = this.ctx.createBufferSource();
                    src.buffer = buf;
                    src.loop = true;
                    const gain = this.ctx.createGain();
                    gain.gain.value = 0.18;
                    src.connect(gain);
                    gain.connect(this.master);
                    src.start();
                } catch(e) {
                    console.warn('Could not load bird sounds:', e);
                }
            },

            async loadSheep() {
                try {
                    const resp = await fetch('https://archive.org/download/SheepSound/SheepSound.mp3');
                    const arr = await resp.arrayBuffer();
                    this.sheepBuffer = await this.ctx.decodeAudioData(arr);
                    this.scheduleSheep();
                } catch(e) {
                    console.warn('Could not load sheep sounds:', e);
                }
            },

            scheduleSheep() {
                if (!this.sheepBuffer) return;
                const delay = 18000 + Math.random() * 35000; // 18-53s apart
                setTimeout(() => {
                    if (this.active) {
                        const src = this.ctx.createBufferSource();
                        src.buffer = this.sheepBuffer;
                        src.playbackRate.value = 0.85 + Math.random() * 0.3;

                        const filter = this.ctx.createBiquadFilter();
                        filter.type = 'lowpass';
                        filter.frequency.value = 1000 + Math.random() * 400;

                        const gain = this.ctx.createGain();
                        gain.gain.value = 0.025 + Math.random() * 0.02;

                        // Pan left or right for spatial feel
                        const pan = this.ctx.createStereoPanner();
                        pan.pan.value = (Math.random() - 0.5) * 1.6;

                        src.connect(filter);
                        filter.connect(gain);
                        gain.connect(pan);
                        pan.connect(this.master);
                        src.start();
                    }
                    this.scheduleSheep();
                }, delay);
            }
        };

        document.getElementById('sound-btn').addEventListener('click', () => Sound.toggle());

        init();
    </script>
</body>
</html>