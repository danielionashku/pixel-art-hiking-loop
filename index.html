<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Pixel Art Hiking Loop</title>
    <style>
        body, html {
            margin: 0;
            padding: 0;
            width: 100%;
            height: 100%;
            background-color: #000;
            overflow: hidden;
            font-family: sans-serif;
        }
        canvas {
            display: block;
            width: 100vw;
            height: 100vh;
            image-rendering: -moz-crisp-edges;
            image-rendering: -webkit-optimize-contrast;
            image-rendering: crisp-edges;
            image-rendering: pixelated;
        }
        #audio-controls {
            position: absolute;
            top: 10px;
            right: 10px;
            z-index: 10;
        }
        #audio-toggle {
            background: rgba(0,0,0,0.5);
            color: #fff;
            border: 1px solid rgba(255,255,255,0.3);
            padding: 8px 12px;
            cursor: pointer;
            font-size: 16px;
            border-radius: 4px;
            letter-spacing: 1px;
        }
        #audio-toggle:hover {
            background: rgba(0,0,0,0.7);
        }
        #audio-panel {
            display: none;
            background: rgba(0,0,0,0.6);
            backdrop-filter: blur(4px);
            padding: 12px;
            margin-top: 4px;
            border-radius: 4px;
            min-width: 150px;
            border: 1px solid rgba(255,255,255,0.15);
        }
        #audio-panel.open {
            display: block;
        }
        .audio-slider {
            margin: 8px 0;
        }
        .audio-slider label {
            color: rgba(255,255,255,0.8);
            font-size: 11px;
            display: block;
            margin-bottom: 3px;
            letter-spacing: 0.5px;
        }
        .audio-slider input[type="range"] {
            width: 100%;
            -webkit-appearance: none;
            appearance: none;
            height: 4px;
            background: rgba(255,255,255,0.2);
            border-radius: 2px;
            outline: none;
        }
        .audio-slider input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 12px;
            height: 12px;
            background: #fff;
            border-radius: 50%;
            cursor: pointer;
        }
    </style>
</head>
<body>
    <div id="audio-controls">
        <button id="audio-toggle">&#9835; Sound</button>
        <div id="audio-panel">
            <div class="audio-slider">
                <label>Music</label>
                <input type="range" min="0" max="100" value="50" data-channel="music">
            </div>
            <div class="audio-slider">
                <label>Wind</label>
                <input type="range" min="0" max="100" value="20" data-channel="wind">
            </div>
            <div class="audio-slider">
                <label>Birds</label>
                <input type="range" min="0" max="100" value="30" data-channel="birds">
            </div>
            <div class="audio-slider">
                <label>Steps</label>
                <input type="range" min="0" max="100" value="40" data-channel="footsteps">
            </div>
            <div class="audio-slider">
                <label>Sheep</label>
                <input type="range" min="0" max="100" value="8" data-channel="sheep">
            </div>
        </div>
    </div>
    <canvas id="game"></canvas>

    <script>
        const canvas = document.getElementById('game');
        const ctx = canvas.getContext('2d');

        const PIXEL_SCALE = 3;
        let cx = 0;
        let HORIZON = 0;

        let time = 0;
        let cameraZ = 0;
        const SPEED = 0.25;
        const FOV = 200;
        const CAMERA_Y = 60;
        const MAX_Z = 2500;

        let entities = [];
        let clouds = [];
        let mountains = { far: [], mid: [], near: [] };
        let birds = [];
        let sheeps = [];
        let midSheeps = [];
        // Dog behavior state machine
        let dogState = {
            mode: 'walk',     // walk, runForward, sniff, runSide, returnBack
            timer: 0,         // frames until next state change
            offsetX: 30,      // current X offset from character (start to the right)
            offsetY: -5,      // current Y offset from character (slightly ahead)
            targetX: 30,      // target X offset
            targetY: -5,      // target Y offset
            facing: 1,        // 1=forward/right, -1=left
            speedMult: 1,     // animation speed multiplier
        };

        const PALETTE = {
            skyBands: ['#a8d8f0', '#b4def2', '#c4e4f5', '#d0eaf0', '#d8ecf0', '#e2f0e0', '#eef2d8', '#f2eac0', '#f5dfa0', '#f0c880', '#e8b070', '#e0a060'],
            sun: '#ffc15e', sunMid: '#ffd070', sunOuter: '#ffe0a0', sunGlow: '#fff0c8',
            cloudLight: '#ffffff',
            cloudBase: '#f0eff0',
            cloudShadow: '#d8d0c8',

            hillFar: '#7a9a6e', hillFarLight: '#8dab7d', hillFarShadow: '#6a8860', hillFarTree: '#5c7a52',
            hillMid: '#6d8e4a', hillMidLight: '#7ea058', hillMidShadow: '#5a7a3c', hillMidTree: '#4a6830', hillMidField: '#8ba55c',
            hillNear: '#5e7e38', hillNearLight: '#72943e', hillNearShadow: '#4c6a2c', hillNearTree: '#3a5822', hillNearField: '#7d9c48', hillNearDark: '#3e5520',

            grassLight: '#94a161', grassDark: '#78854a', grassDarker: '#5c6934',
            grassMid: '#869550', grassHighlight: '#a8b070', grassTipHighlight: '#b8c278',
            grassShades: ['#6c7a38', '#5c6934', '#94a161', '#78854a', '#4b5726', '#869550', '#a8b070', '#7a8c44'],

            dirtMid: '#9a845c', dirtEdge: '#8a9058',
            pebbleLight: '#b0a890', pebbleMid: '#908068', pebbleDark: '#706050',
            flowerColors: ['#e84848', '#d43838', '#f0e040', '#e8d030', '#f0f0e0', '#d8d0c0', '#b060d0', '#9848b0'],
            flowerStemGreen: '#5c7830',
            treeTrunk: '#443125', treeTrunkDark: '#241810',
            pineLeavesBase: ['#2b4a2e', '#325736', '#3b663f'],
            pineLeavesHigh: ['#3b663f', '#46784a', '#528c57'],
            pineLeavesShadow: ['#162618', '#1c301e', '#213823'],
            oakLeavesBase: ['#59662f', '#667536', '#75873e'],
            oakLeavesHigh: ['#75873e', '#869947', '#99ad52'],
            oakLeavesShadow: ['#333b1b', '#3d4720', '#485426'],
            oakLeafColors: ['#d48d3d', '#d4783a', '#cc6630', '#e09040', '#b85c28', '#c87838', '#99ad52', '#b5a142'],

            treeOutline: '#1e3318',
            treeShadowDrop: 'rgba(20, 35, 15, 0.3)',
            rimLight: '#c8d878',
            rimLightBright: '#dae89a',
            hazeColor: { r: 138, g: 171, b: 110 },

            horizonHaze: { r: 215, g: 205, b: 170 },

            groundLeafColors: ['#8b6e3e', '#7a5c2e', '#6b4e28', '#9a7a42', '#a08848', '#b5a142', '#99ad52', '#869947', '#d48d3d', '#c47830'],
        };

        const HAZE_FAR = 0.45;
        const HAZE_MID = 0.22;
        const HAZE_NEAR = 0.08;

        function hexToRgb(hex) {
            return { r:parseInt(hex.slice(1,3),16), g:parseInt(hex.slice(3,5),16), b:parseInt(hex.slice(5,7),16) };
        }
        function rgbToHex(r,g,b) {
            return '#'+((1<<24)+(Math.round(Math.min(255,Math.max(0,r)))<<16)+(Math.round(Math.min(255,Math.max(0,g)))<<8)+Math.round(Math.min(255,Math.max(0,b)))).toString(16).slice(1);
        }
        function lerpColor(hex, hazeRgb, t) {
            let c = hexToRgb(hex);
            return rgbToHex(c.r+(hazeRgb.r-c.r)*t, c.g+(hazeRgb.g-c.g)*t, c.b+(hazeRgb.b-c.b)*t);
        }
        function haze(hex, amount) {
            return lerpColor(hex, PALETTE.horizonHaze, amount);
        }

        function resize() {
            canvas.width = Math.ceil(window.innerWidth/PIXEL_SCALE);
            canvas.height = Math.ceil(window.innerHeight/PIXEL_SCALE);
            cx = canvas.width/2;
            HORIZON = canvas.height*0.55;
            ctx.imageSmoothingEnabled = false;
            generateMountains();
        }

        function hash(n) { let x=Math.sin(n)*43758.5453; return x-Math.floor(x); }

        function generateMountains() {
            let cw = canvas.width;
            mountains.far = [
                { x:cw*0.15, w:cw*1.0, h:65+Math.random()*20, seed:Math.random()*999 },
                { x:cw*0.6, w:cw*1.3, h:80+Math.random()*20, seed:Math.random()*999 },
                { x:cw*1.05, w:cw*0.9, h:58+Math.random()*20, seed:Math.random()*999 },
            ];
            mountains.mid = [
                { x:cw*0.1, w:cw*1.1, h:50+Math.random()*15, seed:Math.random()*999 },
                { x:cw*0.55, w:cw*1.4, h:55+Math.random()*15, seed:Math.random()*999 },
                { x:cw*1.0, w:cw*1.0, h:45+Math.random()*15, seed:Math.random()*999 },
            ];
            mountains.near = [
                { x:cw*0.25, w:cw*1.5, h:35+Math.random()*12, seed:Math.random()*999 },
                { x:cw*0.85, w:cw*1.4, h:40+Math.random()*12, seed:Math.random()*999 },
            ];
            sheeps = [];
            for (let i=0; i<17; i++) {
                sheeps.push({ x:Math.random()*cw, y:HORIZON-8-Math.random()*20,
                    speed:(Math.random()>0.5?1:-1)*(0.00144+Math.random()*0.00288), offset:Math.random()*100 });
            }
            midSheeps = [];
            mountains.mid.forEach(m => {
                let left = Math.max(0, m.x - m.w/2);
                let right = Math.min(cw, m.x + m.w/2);
                let count = 4 + Math.floor(Math.random() * 4); // 4-7 per mid hill
                for (let i = 0; i < count; i++) {
                    let sx = left + Math.random() * (right - left);
                    midSheeps.push({
                        x: sx, hill: m,
                        speed: (Math.random() > 0.5 ? 1 : -1) * (0.001 + Math.random() * 0.002),
                        offset: Math.random() * 100,
                        leftBound: left, rightBound: right
                    });
                }
            });
        }

        function getHillY(m, px) {
            let t=(px-(m.x-m.w/2))/m.w;
            if (t<0||t>1) return HORIZON;
            return HORIZON - Math.sin(t*Math.PI)*m.h - Math.sin(t*Math.PI*4.5+m.seed)*m.h*0.08
                - Math.sin(t*Math.PI*7.2+m.seed*1.7)*m.h*0.04 - Math.sin(t*Math.PI*11.0+m.seed*2.3)*m.h*0.025;
        }

        function fillHillWithVerticalFade(m, baseColor, hazeAmount) {
            let left=Math.max(0,Math.floor(m.x-m.w/2)), right=Math.min(canvas.width,Math.ceil(m.x+m.w/2));
            let hazedBase = haze(baseColor, hazeAmount);
            ctx.fillStyle = hazedBase;
            ctx.beginPath(); ctx.moveTo(left, HORIZON);
            for (let px=left; px<=right; px++) ctx.lineTo(px, getHillY(m, px));
            ctx.lineTo(right, HORIZON); ctx.closePath(); ctx.fill();

            let minY = HORIZON;
            for (let px=left; px<=right; px+=4) { let y=getHillY(m,px); if(y<minY) minY=y; }
            let hillHeight = HORIZON - minY;
            if (hillHeight < 2) return;

            let extraFade = hazeAmount * 0.4;
            let hazedBottom = haze(baseColor, Math.min(0.85, hazeAmount + extraFade));
            let bottomRgb = hexToRgb(hazedBottom);
            let baseRgb = hexToRgb(hazedBase);

            let fadeStart = minY + hillHeight * 0.4;
            for (let y = Math.floor(fadeStart); y < HORIZON; y++) {
                let fadeT = (y - fadeStart) / (HORIZON - fadeStart);
                fadeT = fadeT * fadeT;
                let rowColor = rgbToHex(
                    baseRgb.r + (bottomRgb.r - baseRgb.r) * fadeT,
                    baseRgb.g + (bottomRgb.g - baseRgb.g) * fadeT,
                    baseRgb.b + (bottomRgb.b - baseRgb.b) * fadeT
                );
                ctx.fillStyle = rowColor;
                for (let px = left; px < right; px += 3) {
                    if (getHillY(m, px) <= y) {
                        ctx.fillRect(px, y, 3, 1);
                    }
                }
            }
        }

        function drawHillPatches(m, lightColor, shadowColor, fieldColor, hazeAmount) {
            let left=Math.max(0,Math.floor(m.x-m.w/2)), right=Math.min(canvas.width,Math.ceil(m.x+m.w/2));
            let hLight = haze(lightColor, hazeAmount);
            let hShadow = haze(shadowColor, hazeAmount);
            let hField = haze(fieldColor, hazeAmount);

            for (let px=left+2; px<right-2; px++) {
                let slope = getHillY(m,px+2)-getHillY(m,px);
                if (slope>0.3) { ctx.fillStyle=hShadow; ctx.fillRect(px, Math.round(getHillY(m,px)), 1, Math.round(HORIZON-getHillY(m,px))); }
                else if (slope<-0.3) { ctx.fillStyle=hLight; ctx.fillRect(px, Math.round(getHillY(m,px)), 1, Math.round(HORIZON-getHillY(m,px))); }
            }
            let np=3+Math.floor(hash(m.seed)*4);
            for (let i=0; i<np; i++) {
                let t=0.15+hash(m.seed+i*17)*0.7, px=m.x-m.w/2+t*m.w, pw=8+hash(m.seed+i*31)*25;
                let py=getHillY(m,px), ph=(HORIZON-py)*(0.2+hash(m.seed+i*7)*0.4);
                if (px>0&&px+pw<canvas.width) { ctx.fillStyle=hField; ctx.fillRect(Math.round(px),Math.round(py+(HORIZON-py)*0.2),Math.round(pw),Math.round(ph)); }
            }
        }

        function drawTreeLine(m, treeColor, density, maxTreeH, hazeAmount) {
            let left=Math.max(0,Math.floor(m.x-m.w/2)), right=Math.min(canvas.width,Math.ceil(m.x+m.w/2));
            ctx.fillStyle = haze(treeColor, hazeAmount);
            for (let px=left; px<right; px+=2) {
                let y=getHillY(m,px); if (y>=HORIZON-2) continue;
                if (hash(px*0.37+m.seed*1.1)>density) continue;
                let treeH=2+hash(px*0.53+m.seed)*maxTreeH, treeW=1+Math.floor(hash(px*0.71+m.seed)*2);
                let ty=Math.round(y);
                ctx.fillRect(px, ty-treeH, treeW, treeH);
                if (treeH>3) ctx.fillRect(px-1, ty-treeH, treeW+1, Math.round(treeH*0.4));
            }
        }

        function drawHedgeRow(m, color, hazeAmount) {
            let left=Math.max(0,Math.floor(m.x-m.w/2)), right=Math.min(canvas.width,Math.ceil(m.x+m.w/2));
            let band=0.3+hash(m.seed*3.7)*0.3;
            ctx.fillStyle = haze(color, hazeAmount);
            for (let px=left; px<right; px++) {
                let topY=getHillY(m,px), bandY=topY+(HORIZON-topY)*band;
                if (bandY<HORIZON-1) { ctx.fillRect(px, Math.round(bandY), 1, 1);
                    if (hash(px*0.19+m.seed)>0.6) ctx.fillRect(px, Math.round(bandY)-1, 1, 1); }
            }
        }

        function drawStaticHomes(m, wallColor, roofColor, hazeAmount, count) {
            let left = Math.max(0, Math.floor(m.x - m.w / 2));
            let right = Math.min(canvas.width, Math.ceil(m.x + m.w / 2));
            let hWall = haze(wallColor, hazeAmount);
            let hRoof = haze(roofColor, hazeAmount);
            for (let i = 0; i < count; i++) {
                let t = 0.15 + hash(m.seed + i * 23.7) * 0.7;
                let px = Math.round(m.x - m.w / 2 + t * m.w);
                if (px < left + 5 || px > right - 5) continue;
                let py = Math.round(getHillY(m, px));
                if (py >= HORIZON - 2) continue;
                let w = 2 + Math.round(hash(m.seed + i * 41.3) * 2); // 2-4px wide
                let h = 2 + Math.round(hash(m.seed + i * 53.1)); // 2-3px tall
                // Body
                ctx.fillStyle = hWall;
                ctx.fillRect(px, py - h, w, h);
                // Roof (1px tall, slightly wider)
                ctx.fillStyle = hRoof;
                ctx.fillRect(px - 1, py - h - 1, w + 2, 1);
            }
        }

        // Random tree placement across full width, excluding center path
        function getRandomTreeX() {
            let x;
            do {
                x = (Math.random() - 0.5) * 3000; // range -1500 to 1500
            } while (Math.abs(x) < 180 || x > 420); // exclude center path and river
            return x;
        }

        function getGrassVariant(x,z) {
            let noise=Math.sin(x*0.002)+Math.cos(z*0.002)+Math.sin((x+z)*0.003);
            if (noise>1.2) return 8+Math.floor(Math.random()*2);
            return Math.floor(Math.random()*8);
        }

        function resetLeaf(leaf) {
            let trees=entities.filter(e=>e.type==='tree');
            if (!trees.length) return;
            let tree=trees[Math.floor(Math.random()*trees.length)];
            let isPine=(tree.variant%2===0);
            leaf.x=tree.x+(Math.random()-0.5)*300; // wider X spread (+/-150)
            leaf.z=tree.z-80+Math.random()*120; // range -80 to +40 from tree (negative = in front)
            leaf.y=-10-Math.random()*200; // higher starting Y (-10 to -210)
            leaf.speedY=0.03+Math.random()*0.06;
            leaf.treeType=isPine?0:1;
            leaf.shape=Math.floor(Math.random()*3); // 0=diamond, 1=oval, 2=needle
            let colors=isPine?PALETTE.pineLeavesHigh:PALETTE.oakLeafColors;
            leaf.color=colors[Math.floor(Math.random()*colors.length)];
        }

        // Ground leaf cluster functions
        function createGroundLeaves() {
            let groundLeaves = [];
            let trees = entities.filter(e => e.type === 'tree');

            // 3-5 leaves per tree base
            trees.forEach(tree => {
                let count = 3 + Math.floor(Math.random() * 3);
                for (let i = 0; i < count; i++) {
                    groundLeaves.push({
                        type: 'groundLeaf',
                        x: tree.x + (Math.random() - 0.5) * 120,
                        y: CAMERA_Y,
                        z: tree.z + (Math.random() - 0.5) * 60,
                        color: PALETTE.groundLeafColors[Math.floor(Math.random() * PALETTE.groundLeafColors.length)],
                        w: 2 + Math.random() * 3,
                        h: 1.5 + Math.random() * 2,
                    });
                }
            });

            // 20 scattered random ground leaves
            for (let i = 0; i < 20; i++) {
                groundLeaves.push({
                    type: 'groundLeaf',
                    x: (Math.random() - 0.5) * 2000,
                    y: CAMERA_Y,
                    z: Math.random() * MAX_Z,
                    color: PALETTE.groundLeafColors[Math.floor(Math.random() * PALETTE.groundLeafColors.length)],
                    w: 2 + Math.random() * 3,
                    h: 1.5 + Math.random() * 2,
                });
            }
            return groundLeaves;
        }

        function drawGroundLeaf(sx, sy, scale, leaf) {
            let w = Math.max(1, leaf.w * scale);
            let h = Math.max(1, leaf.h * scale);
            ctx.fillStyle = leaf.color;
            ctx.fillRect(Math.round(sx - w/2), Math.round(sy - h), Math.round(w), Math.round(h));
        }

        // --- Shared home helpers ---
        function homeColors(home, hazeFactor) {
            let hz = PALETTE.hazeColor;
            return {
                wall: lerpColor(home.wallColor, hz, hazeFactor),
                wallDark: lerpColor(home.wallDarkColor, hz, hazeFactor),
                wallShadow: lerpColor('#8a7a60', hz, hazeFactor),
                wallHighlight: lerpColor('#e0d4b8', hz, hazeFactor),
                roof: lerpColor(home.roofColor, hz, hazeFactor),
                roofDark: lerpColor(home.roofDarkColor, hz, hazeFactor),
                roofHighlight: lerpColor('#a85050', hz, hazeFactor),
                trim: lerpColor('#e8dcc8', hz, hazeFactor),
                trimDark: lerpColor('#c4b8a0', hz, hazeFactor),
                door: lerpColor(home.doorColor, hz, hazeFactor),
                doorDark: lerpColor('#3a2518', hz, hazeFactor),
                doorFrame: lerpColor('#7a6848', hz, hazeFactor),
                winLight: lerpColor('#ffffcc', hz, hazeFactor),
                winWarm: lerpColor('#fff0a0', hz, hazeFactor),
                winFrame: lerpColor('#5a4a3a', hz, hazeFactor),
                shutter: lerpColor('#4a6a4a', hz, hazeFactor),
                chimney: lerpColor('#6a5040', hz, hazeFactor),
                chimDark: lerpColor('#4a3028', hz, hazeFactor),
                outline: lerpColor('#2a1e14', hz, hazeFactor),
                eave: lerpColor('#3a2a1a', hz, hazeFactor),
                step: lerpColor('#9a9088', hz, hazeFactor),
                cornerStone: lerpColor('#b8a890', hz, hazeFactor),
            };
        }
        function drawWindow(x, y, w, h, c, s) {
            let crossW = Math.max(1, Math.round(s * 0.5));
            ctx.fillStyle = c.winFrame;
            ctx.fillRect(x - 1, y - 1, w + 2, h + 2);
            ctx.fillStyle = c.winLight;
            ctx.fillRect(x, y, w, h);
            ctx.fillStyle = c.winFrame;
            ctx.fillRect(x + Math.floor(w / 2), y, crossW, h);
            ctx.fillRect(x, y + Math.floor(h / 2), w, crossW);
        }
        function drawTriangleRoof(peakX, baseY, rh, roofW, c, s) {
            let topY = baseY - rh;
            ctx.fillStyle = c.outline;
            for (let r = 0; r <= rh; r++) {
                let frac = r / rh;
                let rw = Math.round(roofW * (0.05 + frac * 0.95));
                ctx.fillRect(peakX - Math.round(rw / 2) - 1, topY + r, rw + 2, 1);
            }
            for (let r = 0; r <= rh; r++) {
                let frac = r / rh;
                let rw = Math.max(1, Math.round(roofW * (0.05 + frac * 0.95)));
                let rx = peakX - Math.round(rw / 2);
                ctx.fillStyle = c.roof;
                ctx.fillRect(rx, topY + r, Math.ceil(rw / 2), 1);
                ctx.fillStyle = c.roofDark;
                ctx.fillRect(rx + Math.ceil(rw / 2), topY + r, rw - Math.ceil(rw / 2), 1);
            }
            ctx.fillStyle = c.trim;
            ctx.fillRect(peakX - 1, topY, 3, Math.max(1, Math.round(s)));
        }
        function drawChimneyAndSmoke(cx2, cy2, cw, ch, home, hazeFactor, s) {
            let hz = PALETTE.hazeColor;
            let c = homeColors(home, hazeFactor);
            ctx.fillStyle = c.chimney;
            ctx.fillRect(cx2, cy2, cw, ch);
            ctx.fillStyle = c.chimDark;
            ctx.fillRect(cx2 + Math.ceil(cw / 2), cy2, cw - Math.ceil(cw / 2), ch);
            ctx.fillStyle = c.chimDark;
            ctx.fillRect(cx2 - 1, cy2, cw + 2, Math.max(1, Math.round(s)));
            if (home.hasSmoke) {
                let smokeX = cx2 + Math.round(cw / 2);
                let smokeCol = lerpColor('#d0d0d0', hz, hazeFactor);
                for (let p = 0; p < 4; p++) {
                    let age = ((time * 0.003 + home.smokeSeed + p * 1.7) % 4) / 4;
                    let py = cy2 - age * 30 * s;
                    let px = smokeX + Math.sin(age * 5 + home.smokeSeed) * 4 * s;
                    let pSize = Math.max(1, Math.round((1.5 + age * 3) * s));
                    ctx.globalAlpha = Math.max(0.02, (1 - age) * 0.5 - hazeFactor * 0.3);
                    ctx.fillStyle = smokeCol;
                    ctx.fillRect(Math.round(px - pSize / 2), Math.round(py - pSize / 2), pSize, pSize);
                    let pSize2 = Math.max(1, Math.round(pSize * 0.7));
                    ctx.fillRect(Math.round(px - pSize2 / 2 + s), Math.round(py - pSize2 / 2 - s), pSize2, pSize2);
                }
                ctx.globalAlpha = 1;
            }
        }

        // --- Type 0: Cottage (compact, peaked roof) ---
        function drawHomeCottage(sx, sy, s, home, hazeFactor) {
            let c = homeColors(home, hazeFactor);
            let bw = Math.max(5, Math.round(16 * s));
            let bh = Math.max(4, Math.round(12 * s));
            let bx = Math.round(sx - bw / 2);
            let by = Math.round(sy - bh);
            let rh = Math.max(3, Math.round(8 * s));
            let ovh = Math.max(1, Math.round(2 * s));
            let ps = Math.max(1, Math.round(s)); // pixel size unit
            // Shadow under house
            ctx.fillStyle = c.eave;
            ctx.globalAlpha = 0.3;
            ctx.fillRect(bx + 1, Math.round(sy), bw, ps);
            ctx.globalAlpha = 1;
            // Outline + walls
            ctx.fillStyle = c.outline;
            ctx.fillRect(bx - 1, by - 1, bw + 2, bh + 2);
            let hw = Math.floor(bw / 2);
            ctx.fillStyle = c.wall; ctx.fillRect(bx, by, hw, bh);
            ctx.fillStyle = c.wallDark; ctx.fillRect(bx + hw, by, bw - hw, bh);
            // Corner stones
            ctx.fillStyle = c.cornerStone;
            for (let cs = 0; cs < 3; cs++) {
                let csY = by + Math.round(bh * (0.1 + cs * 0.3));
                ctx.fillRect(bx, csY, ps, Math.max(2, Math.round(3 * s)));
                ctx.fillRect(bx + bw - ps, csY, ps, Math.max(2, Math.round(3 * s)));
            }
            // Wall highlight stripe (light edge on left)
            ctx.fillStyle = c.wallHighlight;
            ctx.globalAlpha = 0.4;
            ctx.fillRect(bx + ps, by + ps, ps, bh - ps * 2);
            ctx.globalAlpha = 1;
            // Trim band
            ctx.fillStyle = c.trim; ctx.fillRect(bx, by + Math.round(bh * 0.48), bw, ps);
            ctx.fillStyle = c.trimDark; ctx.fillRect(bx, by + Math.round(bh * 0.48) + ps, bw, Math.max(1, Math.round(s * 0.5)));
            // Baseboard
            ctx.fillStyle = c.wallShadow; ctx.fillRect(bx, by + bh - Math.max(1, Math.round(2 * s)), bw, Math.max(1, Math.round(2 * s)));
            // Door with frame
            let dw = Math.max(2, Math.round(3 * s)), dh = Math.max(3, Math.round(5 * s));
            let dx = bx + Math.round(bw * 0.6) - Math.round(dw / 2), dy = by + bh - dh;
            ctx.fillStyle = c.doorFrame; ctx.fillRect(dx - ps, dy - ps, dw + ps * 2, dh + ps);
            ctx.fillStyle = c.door; ctx.fillRect(dx, dy, dw, dh);
            ctx.fillStyle = c.doorDark; ctx.fillRect(dx, dy, dw, ps);
            ctx.fillStyle = c.doorDark; ctx.fillRect(dx + Math.floor(dw / 2), dy, Math.max(1, Math.round(s * 0.5)), dh);
            ctx.fillStyle = '#c8b070'; ctx.fillRect(dx + dw - Math.round(2 * s), dy + Math.round(dh * 0.5), ps, ps);
            // Doorstep
            ctx.fillStyle = c.step; ctx.fillRect(dx - ps, Math.round(sy) - ps, dw + ps * 2, ps);
            // Window with shutters
            let ww = Math.max(2, Math.round(3 * s)), wh = ww;
            let wx = bx + Math.round(bw * 0.15), wy = by + Math.round(bh * 0.18);
            ctx.fillStyle = c.shutter; ctx.fillRect(wx - ps - 1, wy - 1, ps, wh + 2);
            ctx.fillStyle = c.shutter; ctx.fillRect(wx + ww + 1, wy - 1, ps, wh + 2);
            drawWindow(wx, wy, ww, wh, c, s);
            // Window sill
            ctx.fillStyle = c.trim; ctx.fillRect(wx - 1, wy + wh + 1, ww + 2, ps);
            // Eave shadow under roof
            ctx.fillStyle = c.eave;
            ctx.globalAlpha = 0.5;
            ctx.fillRect(bx - ovh, by, bw + ovh * 2, ps);
            ctx.globalAlpha = 1;
            // Roof
            drawTriangleRoof(Math.round(sx), by, rh, bw + ovh * 2, c, s);
            // Chimney
            if (home.hasChimney) {
                let cw = Math.max(2, Math.round(3 * s)), ch = Math.max(3, Math.round(6 * s));
                drawChimneyAndSmoke(bx + Math.round(bw * 0.2), by - rh + Math.round(rh * 0.3) - ch, cw, ch, home, hazeFactor, s);
            }
        }

        // --- Type 1: Tall house (narrow, two floors, steep roof) ---
        function drawHomeTall(sx, sy, s, home, hazeFactor) {
            let c = homeColors(home, hazeFactor);
            let bw = Math.max(5, Math.round(12 * s));
            let bh = Math.max(6, Math.round(18 * s));
            let bx = Math.round(sx - bw / 2);
            let by = Math.round(sy - bh);
            let rh = Math.max(3, Math.round(10 * s));
            let ovh = Math.max(1, Math.round(2 * s));
            let ps = Math.max(1, Math.round(s));
            // Shadow under house
            ctx.fillStyle = c.eave;
            ctx.globalAlpha = 0.3;
            ctx.fillRect(bx + 1, Math.round(sy), bw, ps);
            ctx.globalAlpha = 1;
            // Outline + walls
            ctx.fillStyle = c.outline; ctx.fillRect(bx - 1, by - 1, bw + 2, bh + 2);
            let hw = Math.floor(bw / 2);
            ctx.fillStyle = c.wall; ctx.fillRect(bx, by, hw, bh);
            ctx.fillStyle = c.wallDark; ctx.fillRect(bx + hw, by, bw - hw, bh);
            // Corner stones on both edges
            ctx.fillStyle = c.cornerStone;
            for (let cs = 0; cs < 5; cs++) {
                let csY = by + Math.round(bh * (0.05 + cs * 0.2));
                ctx.fillRect(bx, csY, ps, Math.max(2, Math.round(2.5 * s)));
                ctx.fillRect(bx + bw - ps, csY, ps, Math.max(2, Math.round(2.5 * s)));
            }
            // Light edge highlight
            ctx.fillStyle = c.wallHighlight;
            ctx.globalAlpha = 0.35;
            ctx.fillRect(bx + ps, by + ps, ps, bh - ps * 2);
            ctx.globalAlpha = 1;
            // Floor divider with double trim
            let floorY = by + Math.round(bh * 0.5);
            ctx.fillStyle = c.trim; ctx.fillRect(bx, floorY, bw, ps);
            ctx.fillStyle = c.trimDark; ctx.fillRect(bx, floorY + ps, bw, Math.max(1, Math.round(s * 0.5)));
            // Baseboard
            ctx.fillStyle = c.wallShadow; ctx.fillRect(bx, by + bh - Math.max(1, Math.round(2 * s)), bw, Math.max(1, Math.round(2 * s)));
            // Door with frame
            let dw = Math.max(2, Math.round(3 * s)), dh = Math.max(3, Math.round(6 * s));
            let dx = Math.round(sx - dw / 2), dy = by + bh - dh;
            ctx.fillStyle = c.doorFrame; ctx.fillRect(dx - ps, dy - ps, dw + ps * 2, dh + ps);
            ctx.fillStyle = c.door; ctx.fillRect(dx, dy, dw, dh);
            ctx.fillStyle = c.doorDark; ctx.fillRect(dx, dy, dw, ps);
            ctx.fillStyle = c.doorDark; ctx.fillRect(dx + Math.floor(dw / 2), dy, Math.max(1, Math.round(s * 0.5)), dh);
            ctx.fillStyle = '#c8b070'; ctx.fillRect(dx + dw - Math.round(2 * s), dy + Math.round(dh * 0.5), ps, ps);
            // Doorstep
            ctx.fillStyle = c.step; ctx.fillRect(dx - ps, Math.round(sy) - ps, dw + ps * 2, ps);
            // Upper floor windows with shutters
            let ww = Math.max(2, Math.round(2.5 * s)), wh = Math.max(2, Math.round(3 * s));
            let uwY = by + Math.round(bh * 0.12);
            let uw1x = bx + Math.round(bw * 0.12), uw2x = bx + Math.round(bw * 0.55);
            ctx.fillStyle = c.shutter;
            ctx.fillRect(uw1x - ps - 1, uwY - 1, ps, wh + 2);
            ctx.fillRect(uw1x + ww + 1, uwY - 1, ps, wh + 2);
            ctx.fillRect(uw2x - ps - 1, uwY - 1, ps, wh + 2);
            ctx.fillRect(uw2x + ww + 1, uwY - 1, ps, wh + 2);
            drawWindow(uw1x, uwY, ww, wh, c, s);
            drawWindow(uw2x, uwY, ww, wh, c, s);
            // Window sills (upper)
            ctx.fillStyle = c.trim;
            ctx.fillRect(uw1x - 1, uwY + wh + 1, ww + 2, ps);
            ctx.fillRect(uw2x - 1, uwY + wh + 1, ww + 2, ps);
            // Ground floor window with shutters
            let gwY = floorY + Math.max(1, Math.round(2 * s));
            let gw1x = bx + Math.round(bw * 0.08);
            ctx.fillStyle = c.shutter;
            ctx.fillRect(gw1x - ps - 1, gwY - 1, ps, wh + 2);
            ctx.fillRect(gw1x + ww + 1, gwY - 1, ps, wh + 2);
            drawWindow(gw1x, gwY, ww, wh, c, s);
            ctx.fillStyle = c.trim; ctx.fillRect(gw1x - 1, gwY + wh + 1, ww + 2, ps);
            // Eave shadow
            ctx.fillStyle = c.eave;
            ctx.globalAlpha = 0.5;
            ctx.fillRect(bx - ovh, by, bw + ovh * 2, ps);
            ctx.globalAlpha = 1;
            // Steep roof
            drawTriangleRoof(Math.round(sx), by, rh, bw + ovh * 2, c, s);
            // Chimney on right side
            if (home.hasChimney) {
                let cw = Math.max(2, Math.round(3 * s)), ch = Math.max(3, Math.round(6 * s));
                drawChimneyAndSmoke(bx + Math.round(bw * 0.65), by - rh + Math.round(rh * 0.35) - ch, cw, ch, home, hazeFactor, s);
            }
        }

        // --- Type 2: Barn (wide, low, large door, gambrel-style roof) ---
        function drawHomeBarn(sx, sy, s, home, hazeFactor) {
            let c = homeColors(home, hazeFactor);
            let bw = Math.max(7, Math.round(24 * s));
            let bh = Math.max(4, Math.round(10 * s));
            let bx = Math.round(sx - bw / 2);
            let by = Math.round(sy - bh);
            let rh = Math.max(3, Math.round(7 * s));
            let ovh = Math.max(1, Math.round(2 * s));
            let ps = Math.max(1, Math.round(s));
            // Shadow under building
            ctx.fillStyle = c.eave;
            ctx.globalAlpha = 0.3;
            ctx.fillRect(bx + 1, Math.round(sy), bw, ps);
            ctx.globalAlpha = 1;
            // Outline + walls
            ctx.fillStyle = c.outline; ctx.fillRect(bx - 1, by - 1, bw + 2, bh + 2);
            let hw = Math.floor(bw / 2);
            ctx.fillStyle = c.wall; ctx.fillRect(bx, by, hw, bh);
            ctx.fillStyle = c.wallDark; ctx.fillRect(bx + hw, by, bw - hw, bh);
            // Light edge highlight
            ctx.fillStyle = c.wallHighlight;
            ctx.globalAlpha = 0.3;
            ctx.fillRect(bx + ps, by + ps, ps, bh - ps * 2);
            ctx.globalAlpha = 1;
            // Horizontal plank lines with subtle shadow
            for (let pl = 0; pl < 3; pl++) {
                let plY = by + Math.round(bh * (0.25 + pl * 0.25));
                ctx.fillStyle = c.wallDark; ctx.fillRect(bx, plY, bw, Math.max(1, Math.round(s * 0.5)));
                ctx.fillStyle = c.wallShadow;
                ctx.globalAlpha = 0.3;
                ctx.fillRect(bx, plY + Math.max(1, Math.round(s * 0.5)), bw, Math.max(1, Math.round(s * 0.3)));
                ctx.globalAlpha = 1;
            }
            // Baseboard
            ctx.fillStyle = c.wallShadow; ctx.fillRect(bx, by + bh - Math.max(1, Math.round(2 * s)), bw, Math.max(1, Math.round(2 * s)));
            // Corner posts (barn structural)
            ctx.fillStyle = c.cornerStone;
            ctx.fillRect(bx, by, ps, bh);
            ctx.fillRect(bx + bw - ps, by, ps, bh);
            // Large barn door with frame
            let dw = Math.max(4, Math.round(6 * s)), dh = Math.max(4, Math.round(7 * s));
            let dx = Math.round(sx - dw / 2), dy = by + bh - dh;
            ctx.fillStyle = c.doorFrame; ctx.fillRect(dx - ps, dy - ps, dw + ps * 2, dh + ps);
            ctx.fillStyle = c.door; ctx.fillRect(dx, dy, dw, dh);
            ctx.fillStyle = c.doorDark; ctx.fillRect(dx, dy, dw, ps);
            // Door split line
            ctx.fillStyle = c.doorDark; ctx.fillRect(Math.round(sx), dy, Math.max(1, Math.round(s * 0.5)), dh);
            // Cross brace on door
            ctx.fillStyle = c.doorDark;
            let braceW = Math.max(1, Math.round(s * 0.5));
            for (let br = 0; br < dh; br++) {
                let frac = br / dh;
                ctx.fillRect(dx + Math.round(frac * dw * 0.45), dy + br, braceW, 1);
                ctx.fillRect(dx + dw - Math.round(frac * dw * 0.45) - braceW, dy + br, braceW, 1);
            }
            // Side windows (one on each side of door)
            let swW = Math.max(2, Math.round(2 * s)), swH = Math.max(2, Math.round(2 * s));
            let swY = by + Math.round(bh * 0.25);
            drawWindow(bx + Math.round(bw * 0.08), swY, swW, swH, c, s);
            drawWindow(bx + Math.round(bw * 0.78), swY, swW, swH, c, s);
            // Small hay loft window above door
            let lwW = Math.max(2, Math.round(3 * s)), lwH = Math.max(2, Math.round(2 * s));
            drawWindow(Math.round(sx - lwW / 2), by + Math.round(bh * 0.08), lwW, lwH, c, s);
            // Eave shadow
            ctx.fillStyle = c.eave;
            ctx.globalAlpha = 0.5;
            ctx.fillRect(bx - ovh, by, bw + ovh * 2, ps);
            ctx.globalAlpha = 1;
            // Gambrel-ish roof (two-slope: steep lower, gentler upper)
            let roofW = bw + ovh * 2;
            let topY = by - rh;
            let midY = by - Math.round(rh * 0.4);
            let peakX = Math.round(sx);
            // Roof outline
            ctx.fillStyle = c.outline;
            for (let r = 0; r <= rh; r++) {
                let ry = topY + r;
                let frac, rw;
                if (ry >= midY) {
                    frac = (ry - midY) / (by - midY);
                    rw = Math.round(roofW * (0.6 + frac * 0.4));
                } else {
                    frac = (ry - topY) / (midY - topY);
                    rw = Math.round(roofW * (0.1 + frac * 0.5));
                }
                ctx.fillRect(peakX - Math.round(rw / 2) - 1, ry, rw + 2, 1);
            }
            // Roof fill with left/right shading
            for (let r = 0; r <= rh; r++) {
                let ry = topY + r;
                let frac, rw;
                if (ry >= midY) {
                    frac = (ry - midY) / (by - midY);
                    rw = Math.max(1, Math.round(roofW * (0.6 + frac * 0.4)));
                } else {
                    frac = (ry - topY) / (midY - topY);
                    rw = Math.max(1, Math.round(roofW * (0.1 + frac * 0.5)));
                }
                let rx = peakX - Math.round(rw / 2);
                ctx.fillStyle = c.roof; ctx.fillRect(rx, ry, Math.ceil(rw / 2), 1);
                ctx.fillStyle = c.roofDark; ctx.fillRect(rx + Math.ceil(rw / 2), ry, rw - Math.ceil(rw / 2), 1);
                // Subtle highlight on left edge
                if (rw > 4) {
                    ctx.fillStyle = c.roofHighlight;
                    ctx.globalAlpha = 0.25;
                    ctx.fillRect(rx + 1, ry, Math.max(1, Math.round(rw * 0.08)), 1);
                    ctx.globalAlpha = 1;
                }
            }
            // Ridge cap
            ctx.fillStyle = c.trim; ctx.fillRect(peakX - 1, topY, 3, ps);
            // No chimney on barns usually, but allow it
            if (home.hasChimney) {
                let cw = Math.max(2, Math.round(3 * s)), ch = Math.max(3, Math.round(5 * s));
                drawChimneyAndSmoke(bx + Math.round(bw * 0.15), topY + Math.round(rh * 0.2) - ch, cw, ch, home, hazeFactor, s);
            }
        }

        // --- Type 3: Chapel (small body with tall steeple tower on one side) ---
        function drawHomeChapel(sx, sy, s, home, hazeFactor) {
            let c = homeColors(home, hazeFactor);
            // Main body
            let bw = Math.max(5, Math.round(14 * s));
            let bh = Math.max(4, Math.round(10 * s));
            let bx = Math.round(sx - bw / 2);
            let by = Math.round(sy - bh);
            let rh = Math.max(3, Math.round(6 * s));
            let ovh = Math.max(1, Math.round(2 * s));
            // Outline + walls
            ctx.fillStyle = c.outline; ctx.fillRect(bx - 1, by - 1, bw + 2, bh + 2);
            let hw = Math.floor(bw / 2);
            ctx.fillStyle = c.wall; ctx.fillRect(bx, by, hw, bh);
            ctx.fillStyle = c.wallDark; ctx.fillRect(bx + hw, by, bw - hw, bh);
            ctx.fillStyle = c.wallDark; ctx.fillRect(bx, by + bh - Math.max(1, Math.round(2 * s)), bw, Math.max(1, Math.round(2 * s)));
            // Door (center)
            let dw = Math.max(2, Math.round(3 * s)), dh = Math.max(3, Math.round(5 * s));
            let dx = Math.round(sx - dw / 2), dy = by + bh - dh;
            ctx.fillStyle = c.door; ctx.fillRect(dx, dy, dw, dh);
            ctx.fillStyle = c.doorDark; ctx.fillRect(dx, dy, dw, Math.max(1, Math.round(s)));
            // Arched door top (extra pixel above)
            ctx.fillStyle = c.door; ctx.fillRect(dx + Math.max(1, Math.round(s * 0.5)), dy - Math.max(1, Math.round(s)), dw - Math.max(1, Math.round(s)), Math.max(1, Math.round(s)));
            // Small round window on main body
            let ww = Math.max(2, Math.round(2.5 * s)), wh = ww;
            drawWindow(Math.round(sx - ww / 2), by + Math.round(bh * 0.12), ww, wh, c, s);
            // Main body roof
            drawTriangleRoof(Math.round(sx), by, rh, bw + ovh * 2, c, s);
            // Tower / steeple on left side
            let tw = Math.max(3, Math.round(6 * s));
            let th = Math.max(6, Math.round(14 * s));
            let tx = bx - Math.round(tw * 0.3); // slightly overlapping main body
            let ty = by - th + Math.round(bh * 0.3);
            let trh = Math.max(3, Math.round(8 * s)); // tall spire
            // Tower walls
            ctx.fillStyle = c.outline; ctx.fillRect(tx - 1, ty - 1, tw + 2, th + 2);
            ctx.fillStyle = c.wall; ctx.fillRect(tx, ty, Math.ceil(tw / 2), th);
            ctx.fillStyle = c.wallDark; ctx.fillRect(tx + Math.ceil(tw / 2), ty, tw - Math.ceil(tw / 2), th);
            // Tower window (narrow slit)
            let swW = Math.max(1, Math.round(1.5 * s)), swH = Math.max(2, Math.round(3 * s));
            ctx.fillStyle = c.winFrame; ctx.fillRect(tx + Math.round(tw / 2) - Math.round(swW / 2) - 1, ty + Math.round(th * 0.2) - 1, swW + 2, swH + 2);
            ctx.fillStyle = c.winLight; ctx.fillRect(tx + Math.round(tw / 2) - Math.round(swW / 2), ty + Math.round(th * 0.2), swW, swH);
            // Tower spire
            let tPeakX = tx + Math.round(tw / 2);
            drawTriangleRoof(tPeakX, ty, trh, tw + Math.round(s), c, s);
            // Cross on top of spire
            let crossSz = Math.max(1, Math.round(2 * s));
            ctx.fillStyle = c.trim;
            ctx.fillRect(tPeakX, ty - trh - crossSz * 2, Math.max(1, Math.round(s * 0.5)), crossSz * 2);
            ctx.fillRect(tPeakX - Math.round(crossSz * 0.5), ty - trh - Math.round(crossSz * 1.5), crossSz, Math.max(1, Math.round(s * 0.5)));
            // Chimney on main body right side
            if (home.hasChimney) {
                let cw = Math.max(2, Math.round(2 * s)), ch = Math.max(3, Math.round(5 * s));
                drawChimneyAndSmoke(bx + Math.round(bw * 0.7), by - rh + Math.round(rh * 0.3) - ch, cw, ch, home, hazeFactor, s);
            }
        }

        function drawHomeVegetation(sx, sy, s, home, hazeFactor, seedOffset, doorLeftX, doorRightX) {
            let hz = PALETTE.hazeColor;
            let seed = home.smokeSeed * 7.3 + seedOffset;
            let bushColors = [
                lerpColor('#3a6828', hz, hazeFactor),
                lerpColor('#4a7832', hz, hazeFactor),
                lerpColor('#5a8840', hz, hazeFactor),
                lerpColor('#326020', hz, hazeFactor),
            ];
            let darkBush = lerpColor('#2a4a1a', hz, hazeFactor);
            let flowerCols = [
                lerpColor('#e84848', hz, hazeFactor),
                lerpColor('#f0e040', hz, hazeFactor),
                lerpColor('#b060d0', hz, hazeFactor),
                lerpColor('#f0f0e0', hz, hazeFactor),
            ];
            let hw = home.homeType === 2 ? 24 * s : (home.homeType === 1 ? 12 * s : 16 * s);

            let count = 3 + Math.floor(hash(seed) * 4);
            for (let i = 0; i < count; i++) {
                let h2 = hash(seed + i * 13.7);
                let h3 = hash(seed + i * 23.1);
                let h4 = hash(seed + i * 37.9);
                let offX = (h2 - 0.5) * (hw + 20 * s);
                let bx = Math.round(sx + offX);
                let by = Math.round(sy);

                // Skip if this bush would overlap the door zone
                if (doorLeftX !== undefined && bx > doorLeftX && bx < doorRightX) continue;

                if (h4 < 0.55) {
                    let bw = Math.max(2, Math.round((3 + h3 * 4) * s));
                    let bh = Math.max(2, Math.round((2 + h3 * 3) * s));
                    ctx.fillStyle = darkBush;
                    ctx.fillRect(bx - Math.round(bw/2), by - bh + Math.round(bh * 0.3), bw, Math.round(bh * 0.7));
                    ctx.fillStyle = bushColors[i % bushColors.length];
                    ctx.fillRect(bx - Math.round(bw/2), by - bh, bw, Math.round(bh * 0.7));
                    ctx.fillStyle = bushColors[(i+2) % bushColors.length];
                    ctx.fillRect(bx - Math.round(bw/3), by - bh, Math.round(bw * 0.6), Math.max(1, Math.round(bh * 0.3)));
                    if (h3 > 0.6) {
                        ctx.fillStyle = flowerCols[i % flowerCols.length];
                        ctx.fillRect(bx - Math.round(bw * 0.2), by - bh + Math.round(bh * 0.2), Math.max(1, Math.round(s)), Math.max(1, Math.round(s)));
                    }
                } else if (h4 < 0.8) {
                    let ph = Math.max(2, Math.round((4 + h3 * 5) * s));
                    let pw = Math.max(1, Math.round(s));
                    ctx.fillStyle = bushColors[(i+1) % bushColors.length];
                    ctx.fillRect(bx, by - ph, pw, ph);
                    let lw = Math.max(2, Math.round(2 * s));
                    ctx.fillStyle = bushColors[(i+3) % bushColors.length];
                    ctx.fillRect(bx - Math.round(lw/2), by - ph - Math.round(s), lw, Math.max(1, Math.round(2 * s)));
                    ctx.fillRect(bx - Math.round(lw/2) - Math.round(s), by - ph + Math.round(s), Math.round(lw * 0.7), Math.max(1, Math.round(1.5 * s)));
                } else {
                    let cw = Math.max(3, Math.round((4 + h3 * 3) * s));
                    let ch = Math.max(1, Math.round((1 + h3) * s));
                    ctx.fillStyle = bushColors[(i+2) % bushColors.length];
                    ctx.fillRect(bx - Math.round(cw/2), by - ch, cw, ch);
                    ctx.fillStyle = darkBush;
                    ctx.fillRect(bx - Math.round(cw/3), by - Math.round(ch * 0.5), Math.round(cw * 0.5), Math.max(1, Math.round(ch * 0.5)));
                }
            }
        }

        function getHomeDoorZone(sx, s, home) {
            let bw = home.homeType === 2 ? 24 * s : (home.homeType === 1 ? 12 * s : 16 * s);
            let bx = Math.round(sx - bw / 2);
            let dw = home.homeType === 2 ? 6 * s : 3 * s;
            let doorCx = home.homeType === 2 ? sx : (home.homeType === 1 ? sx : bx + bw * 0.6);
            let pad = 3 * s;
            return { left: Math.round(doorCx - dw / 2 - pad), right: Math.round(doorCx + dw / 2 + pad) };
        }

        function drawPicketFence(sx, sy, s, home, hazeFactor) {
            let hz = PALETTE.hazeColor;
            let fenceCol = lerpColor('#f0ece0', hz, hazeFactor);
            let fenceShade = lerpColor('#d0c8b8', hz, hazeFactor);
            let postCol = lerpColor('#e0d8c8', hz, hazeFactor);
            let hw = home.homeType === 2 ? 24 * s : (home.homeType === 1 ? 12 * s : 16 * s);
            let fenceExtend = hw * 0.6; // how far fence extends beyond house
            let fenceH = Math.max(2, Math.round(4 * s));
            let picketW = Math.max(1, Math.round(s));
            let picketSpacing = Math.max(2, Math.round(3 * s));
            let railH = Math.max(1, Math.round(s * 0.5));
            let fenceY = Math.round(sy);
            // Door gap
            let dz = getHomeDoorZone(sx, s, home);
            let fenceLeft = Math.round(sx - hw / 2 - fenceExtend);
            let fenceRight = Math.round(sx + hw / 2 + fenceExtend);
            // Horizontal rails
            ctx.fillStyle = fenceShade;
            ctx.fillRect(fenceLeft, fenceY - Math.round(fenceH * 0.3), dz.left - fenceLeft, railH);
            ctx.fillRect(dz.right, fenceY - Math.round(fenceH * 0.3), fenceRight - dz.right, railH);
            ctx.fillRect(fenceLeft, fenceY - Math.round(fenceH * 0.8), dz.left - fenceLeft, railH);
            ctx.fillRect(dz.right, fenceY - Math.round(fenceH * 0.8), fenceRight - dz.right, railH);
            // Pickets — left section
            for (let px = fenceLeft; px < dz.left; px += picketSpacing) {
                ctx.fillStyle = fenceCol;
                ctx.fillRect(px, fenceY - fenceH, picketW, fenceH);
                // Pointed top
                ctx.fillRect(px, fenceY - fenceH - Math.max(1, Math.round(s * 0.5)), picketW, Math.max(1, Math.round(s * 0.5)));
                // Shade on right edge
                ctx.fillStyle = fenceShade;
                ctx.fillRect(px + picketW - 1, fenceY - fenceH, 1, fenceH);
            }
            // Pickets — right section
            for (let px = dz.right; px < fenceRight; px += picketSpacing) {
                ctx.fillStyle = fenceCol;
                ctx.fillRect(px, fenceY - fenceH, picketW, fenceH);
                ctx.fillRect(px, fenceY - fenceH - Math.max(1, Math.round(s * 0.5)), picketW, Math.max(1, Math.round(s * 0.5)));
                ctx.fillStyle = fenceShade;
                ctx.fillRect(px + picketW - 1, fenceY - fenceH, 1, fenceH);
            }
            // Corner posts (thicker)
            let postW = Math.max(2, Math.round(2 * s));
            ctx.fillStyle = postCol;
            ctx.fillRect(fenceLeft, fenceY - fenceH - Math.round(s), postW, fenceH + Math.round(s));
            ctx.fillRect(fenceRight - postW, fenceY - fenceH - Math.round(s), postW, fenceH + Math.round(s));
        }

        function drawHome(sx, sy, scale, home, relZ) {
            scale *= 6.5;
            let hazeFactor = getTreeHazeFactor(relZ);
            // Draw vegetation behind the house
            drawHomeVegetation(sx, sy, scale, home, hazeFactor, 0);
            let t = home.homeType || 0;
            if (t === 0) drawHomeCottage(sx, sy, scale, home, hazeFactor);
            else if (t === 1) drawHomeTall(sx, sy, scale, home, hazeFactor);
            else if (t === 2) drawHomeBarn(sx, sy, scale, home, hazeFactor);
            else drawHomeChapel(sx, sy, scale, home, hazeFactor);
            // Draw vegetation in front of house, avoiding door
            let dz = getHomeDoorZone(sx, scale, home);
            drawHomeVegetation(sx, sy, scale, home, hazeFactor, 100, dz.left, dz.right);
            // Picket fence around some homes
            if (home.hasFence) drawPicketFence(sx, sy, scale, home, hazeFactor);
        }

        function getRandomHomeX() {
            let x;
            do {
                x = (Math.random() - 0.5) * 2000;
            } while (Math.abs(x) < 250 || x > 380);
            return x;
        }

        function drawPerson(sx, sy, scale, person, relZ) {
            scale *= 3.5;
            let hazeFactor = getTreeHazeFactor(relZ);
            let hz = PALETTE.hazeColor;
            let skinCol = lerpColor('#e8b888', hz, hazeFactor);
            let hairCol = lerpColor(person.hairColor, hz, hazeFactor);
            let shirtCol = lerpColor(person.shirtColor, hz, hazeFactor);
            let pantsCol = lerpColor(person.pantsColor, hz, hazeFactor);
            let shoeCol = lerpColor('#3a2a1a', hz, hazeFactor);
            // Walk animation
            let walk = Math.sin(time * 0.005 + person.walkOffset);
            let legSwing = walk * 1.5;
            let armSwing = -walk * 1.2;
            let bob = Math.abs(walk) * 0.5;
            let py = (x,y,w,h,color) => { drawRect(sx+x*scale, sy+y*scale-bob*scale, w*scale, h*scale, color); };
            // Shadow
            ctx.fillStyle = 'rgba(0,0,0,0.2)';
            ctx.fillRect(Math.round(sx-2*scale), Math.round(sy+6*scale), Math.round(4*scale), Math.round(scale));
            // Legs
            let ll = legSwing > 0 ? -legSwing : 0, rl = legSwing < 0 ? legSwing : 0;
            drawRect(sx-2*scale, sy+(2+ll)*scale-bob*scale, 1.5*scale, (4-ll)*scale, pantsCol);
            drawRect(sx+0.5*scale, sy+(2+rl)*scale-bob*scale, 1.5*scale, (4-rl)*scale, pantsCol);
            // Shoes
            py(-2, 5.5+ll, 1.5, 1, shoeCol); py(0.5, 5.5+rl, 1.5, 1, shoeCol);
            // Body/shirt
            py(-2.5, -3, 5, 5, shirtCol);
            // Arms
            drawRect(sx-3.5*scale, sy+(-2+armSwing)*scale-bob*scale, 1.5*scale, 3*scale, shirtCol);
            drawRect(sx+2*scale, sy+(-2-armSwing)*scale-bob*scale, 1.5*scale, 3*scale, shirtCol);
            // Hands
            drawRect(sx-3.5*scale, sy+(1+armSwing)*scale-bob*scale, 1*scale, 1*scale, skinCol);
            drawRect(sx+2.5*scale, sy+(1-armSwing)*scale-bob*scale, 1*scale, 1*scale, skinCol);
            // Head
            py(-1.5, -6, 3, 3, skinCol);
            // Eyes
            let eyeCol = lerpColor('#1a1410', hz, hazeFactor);
            py(-1, -5, 0.8, 0.8, eyeCol); py(0.5, -5, 0.8, 0.8, eyeCol);
            // Hair
            py(-2, -7, 4, 2, hairCol);
            py(-1.5, -6.5, 3, 1, hairCol);
        }

        function drawGroundSheep(sx, sy, scale, sheep, relZ) {
            scale *= 4;
            let hazeFactor = getTreeHazeFactor(relZ);
            let hz = PALETTE.hazeColor;
            let bodyCol = lerpColor('#f0ece0', hz, hazeFactor);
            let bodyDark = lerpColor('#d8d0c0', hz, hazeFactor);
            let woolHighlight = lerpColor('#ffffff', hz, hazeFactor);
            let legCol = lerpColor('#4a3828', hz, hazeFactor);
            let hoofCol = lerpColor('#2a1a10', hz, hazeFactor);
            let headCol = lerpColor('#2a1e14', hz, hazeFactor);
            let headLight = lerpColor('#4a3a28', hz, hazeFactor);
            let eyeCol = lerpColor('#0a0604', hz, hazeFactor);
            let noseCol = lerpColor('#3a2a1a', hz, hazeFactor);
            let isEating = Math.sin(time * 0.002 + sheep.eatOffset) > 0.5;
            let f = sheep.facing;
            // Shadow
            ctx.fillStyle = 'rgba(0,0,0,0.15)';
            ctx.fillRect(Math.round(sx-3*scale), Math.round(sy+3.5*scale), Math.round(7*scale), Math.round(scale));
            // Legs (4 legs, front pair slightly offset)
            let legW = Math.max(1, Math.round(0.8*scale));
            drawRect(sx-2*scale, sy+1.5*scale, legW, 2*scale, legCol);
            drawRect(sx-0.5*scale, sy+1.5*scale, legW, 2*scale, legCol);
            drawRect(sx+1*scale, sy+1.5*scale, legW, 2*scale, legCol);
            drawRect(sx+2.5*scale, sy+1.5*scale, legW, 2*scale, legCol);
            // Hooves
            drawRect(sx-2*scale, sy+3.2*scale, legW, Math.max(1,0.5*scale), hoofCol);
            drawRect(sx-0.5*scale, sy+3.2*scale, legW, Math.max(1,0.5*scale), hoofCol);
            drawRect(sx+1*scale, sy+3.2*scale, legW, Math.max(1,0.5*scale), hoofCol);
            drawRect(sx+2.5*scale, sy+3.2*scale, legW, Math.max(1,0.5*scale), hoofCol);
            // Body (fluffy wool — rounded)
            drawRect(sx-3*scale, sy-1.5*scale, 6.5*scale, 3.5*scale, bodyCol);
            drawRect(sx-2.5*scale, sy-2.5*scale, 5.5*scale, 1.5*scale, bodyCol);
            drawRect(sx-2*scale, sy-3*scale, 4.5*scale, 1*scale, bodyCol);
            // Wool shadow (underside)
            drawRect(sx-3*scale, sy+1*scale, 6.5*scale, scale*0.8, bodyDark);
            // Wool highlights (fluffy bumps on top)
            ctx.globalAlpha = 0.4;
            drawRect(sx-2*scale, sy-2.8*scale, 2*scale, scale, woolHighlight);
            drawRect(sx+0.5*scale, sy-2.5*scale, 1.5*scale, scale*0.8, woolHighlight);
            ctx.globalAlpha = 1;
            // Tail (small puff)
            let tailX = f > 0 ? -3.5 : 3;
            drawRect(sx+tailX*scale, sy-1*scale, scale*1.2, scale*1.2, bodyCol);
            // Head
            let headY = isEating ? 0.5 : -2;
            let headX = f > 0 ? 3.5 : -4.5;
            drawRect(sx+headX*scale, sy+headY*scale, 2.5*scale, 2.5*scale, headCol);
            // Face lighter patch
            drawRect(sx+(headX+0.5)*scale, sy+(headY+0.5)*scale, 1.5*scale, 1.5*scale, headLight);
            // Eye
            let eyeX = f > 0 ? headX+1.8 : headX+0.2;
            drawRect(sx+eyeX*scale, sy+(headY+0.5)*scale, Math.max(1,0.5*scale), Math.max(1,0.5*scale), eyeCol);
            // Nose/muzzle
            let noseX = f > 0 ? headX+2 : headX-0.3;
            drawRect(sx+noseX*scale, sy+(headY+1.5)*scale, Math.max(1,0.6*scale), Math.max(1,0.4*scale), noseCol);
            // Ears
            let earX1 = f > 0 ? headX+0.3 : headX+1.5;
            drawRect(sx+earX1*scale, sy+(headY-0.8)*scale, scale*0.8, scale*0.8, headCol);
            let earX2 = f > 0 ? headX+1.5 : headX+0.3;
            drawRect(sx+earX2*scale, sy+(headY-0.6)*scale, scale*0.7, scale*0.7, headCol);
        }

        function drawCow(sx, sy, scale, cow, relZ) {
            scale *= 6;
            let hazeFactor = getTreeHazeFactor(relZ);
            let hz = PALETTE.hazeColor;
            let bodyCol = lerpColor(cow.bodyColor, hz, hazeFactor);
            let patchCol = lerpColor(cow.patchColor, hz, hazeFactor);
            let legCol = lerpColor('#3a2a1a', hz, hazeFactor);
            let hoofCol = lerpColor('#1a1008', hz, hazeFactor);
            let headCol = lerpColor(cow.headColor, hz, hazeFactor);
            let headLight = lerpColor('#f0e8d8', hz, hazeFactor);
            let eyeCol = lerpColor('#0a0604', hz, hazeFactor);
            let noseCol = lerpColor('#d8a088', hz, hazeFactor);
            let earCol = lerpColor('#c8a888', hz, hazeFactor);
            let hornCol = lerpColor('#e8dcc8', hz, hazeFactor);
            let tailCol = lerpColor('#4a3828', hz, hazeFactor);
            let udderCol = lerpColor('#f0c8b0', hz, hazeFactor);
            let f = cow.facing;
            // Shadow
            ctx.fillStyle = 'rgba(0,0,0,0.15)';
            ctx.fillRect(Math.round(sx-4*scale), Math.round(sy+4*scale), Math.round(9*scale), Math.round(scale*1.2));
            // Legs (4 legs)
            let legW = Math.max(1, Math.round(scale));
            drawRect(sx-3*scale, sy+1.5*scale, legW, 2.5*scale, legCol);
            drawRect(sx-1*scale, sy+1.5*scale, legW, 2.5*scale, legCol);
            drawRect(sx+1.5*scale, sy+1.5*scale, legW, 2.5*scale, legCol);
            drawRect(sx+3.5*scale, sy+1.5*scale, legW, 2.5*scale, legCol);
            // Hooves
            drawRect(sx-3*scale, sy+3.7*scale, legW, Math.max(1,0.5*scale), hoofCol);
            drawRect(sx-1*scale, sy+3.7*scale, legW, Math.max(1,0.5*scale), hoofCol);
            drawRect(sx+1.5*scale, sy+3.7*scale, legW, Math.max(1,0.5*scale), hoofCol);
            drawRect(sx+3.5*scale, sy+3.7*scale, legW, Math.max(1,0.5*scale), hoofCol);
            // Udder
            drawRect(sx+0.5*scale, sy+1.5*scale, 2*scale, scale, udderCol);
            // Body
            drawRect(sx-4*scale, sy-2*scale, 9*scale, 4*scale, bodyCol);
            drawRect(sx-3.5*scale, sy-2.5*scale, 8*scale, scale, bodyCol);
            // Patches (cow spots)
            drawRect(sx-2*scale, sy-1.5*scale, 3*scale, 2.5*scale, patchCol);
            drawRect(sx+2*scale, sy-0.5*scale, 2*scale, 2*scale, patchCol);
            drawRect(sx-1*scale, sy-2.5*scale, 2*scale, scale, patchCol);
            // Belly highlight
            ctx.globalAlpha = 0.2;
            drawRect(sx-3*scale, sy+1*scale, 7*scale, scale, headLight);
            ctx.globalAlpha = 1;
            // Tail
            let tailX = f > 0 ? -4.5 : 4.5;
            let tailSway = Math.sin(time * 0.003 + cow.walkOffset) * 0.8;
            drawRect(sx+tailX*scale, sy-2*scale, Math.max(1,0.5*scale), 3*scale, tailCol);
            drawRect(sx+(tailX+tailSway*0.5)*scale, sy+0.5*scale, Math.max(1, scale*0.8), Math.max(1, scale*0.6), tailCol);
            // Head
            let headX = f > 0 ? 5 : -6;
            drawRect(sx+headX*scale, sy-2.5*scale, 3*scale, 3*scale, headCol);
            // Lighter face
            drawRect(sx+(headX+0.5)*scale, sy-1.5*scale, 2*scale, 2*scale, headLight);
            // Eye
            let eyeX = f > 0 ? headX+2 : headX+0.3;
            drawRect(sx+eyeX*scale, sy-2*scale, Math.max(1,0.5*scale), Math.max(1,0.5*scale), eyeCol);
            // Nose/muzzle
            let muzzleX = f > 0 ? headX+1.5 : headX;
            drawRect(sx+muzzleX*scale, sy-0.5*scale, 2*scale, scale, noseCol);
            // Nostrils
            drawRect(sx+(muzzleX+0.3)*scale, sy-0.2*scale, Math.max(1,0.3*scale), Math.max(1,0.3*scale), eyeCol);
            drawRect(sx+(muzzleX+1.2)*scale, sy-0.2*scale, Math.max(1,0.3*scale), Math.max(1,0.3*scale), eyeCol);
            // Ears
            let ear1X = f > 0 ? headX+0.2 : headX+2.2;
            drawRect(sx+ear1X*scale, sy-3.2*scale, scale*0.8, scale*0.8, earCol);
            // Horns
            let hornX = f > 0 ? headX+0.8 : headX+1.5;
            drawRect(sx+hornX*scale, sy-3.5*scale, Math.max(1,0.5*scale), scale, hornCol);
            drawRect(sx+(hornX+0.8)*scale, sy-3.5*scale, Math.max(1,0.5*scale), scale, hornCol);
        }

        function drawShepherd(sx, sy, scale, person, relZ) {
            scale *= 3.5;
            let hazeFactor = getTreeHazeFactor(relZ);
            let hz = PALETTE.hazeColor;
            let skinCol = lerpColor('#e8b888', hz, hazeFactor);
            let hairCol = lerpColor(person.hairColor, hz, hazeFactor);
            let shirtCol = lerpColor(person.shirtColor, hz, hazeFactor);
            let pantsCol = lerpColor(person.pantsColor, hz, hazeFactor);
            let shoeCol = lerpColor('#3a2a1a', hz, hazeFactor);
            let staffCol = lerpColor('#6a4a28', hz, hazeFactor);
            let staffLight = lerpColor('#8a6a40', hz, hazeFactor);
            let hatCol = lerpColor('#7a6848', hz, hazeFactor);
            // Standing or slow sway
            let sway = Math.sin(time * 0.002 + person.walkOffset) * 0.3;
            let py = (x,y,w,h,color) => { drawRect(sx+x*scale, sy+y*scale, w*scale, h*scale, color); };
            // Shadow
            ctx.fillStyle = 'rgba(0,0,0,0.2)';
            ctx.fillRect(Math.round(sx-3*scale), Math.round(sy+6*scale), Math.round(6*scale), Math.round(scale));
            // Staff (tall, held in one hand)
            drawRect(sx+3*scale, sy-10*scale, Math.max(1, 0.5*scale), 16*scale, staffCol);
            drawRect(sx+3*scale, sy-10*scale, Math.max(1, 0.8*scale), scale, staffLight); // knob
            // Legs
            py(-2, 2, 1.5, 4, pantsCol);
            py(0.5, 2, 1.5, 4, pantsCol);
            // Shoes
            py(-2, 5.5, 1.5, 1, shoeCol); py(0.5, 5.5, 1.5, 1, shoeCol);
            // Body
            py(-2.5, -3, 5, 5, shirtCol);
            // Arms — one holding staff, one relaxed
            drawRect(sx-3.5*scale, sy+(-2+sway)*scale, 1.5*scale, 3*scale, shirtCol);
            drawRect(sx+2*scale, sy-3*scale, 1.5*scale, 4*scale, shirtCol); // arm reaching up to staff
            // Hands
            drawRect(sx-3.5*scale, sy+(1+sway)*scale, scale, scale, skinCol);
            drawRect(sx+2.5*scale, sy-3*scale, scale, scale, skinCol); // hand on staff
            // Head
            py(-1.5, -6, 3, 3, skinCol);
            // Wide-brim hat
            py(-3, -7.5, 6, 1.5, hatCol);
            py(-2, -8.5, 4, 1.5, hatCol);
            // Hair visible under hat
            py(-1.5, -6.5, 3, 0.5, hairCol);
        }

        function drawBoulder(sx, sy, scale, boulder, relZ) {
            let bs = boulder.bSize;
            scale *= 4 * bs;
            let hazeFactor = getTreeHazeFactor(relZ);
            let hz = PALETTE.hazeColor;
            let baseCol = lerpColor('#7a7568', hz, hazeFactor);
            let darkCol = lerpColor('#5a5548', hz, hazeFactor);
            let lightCol = lerpColor('#9a9588', hz, hazeFactor);
            let highlightCol = lerpColor('#b0aa98', hz, hazeFactor);
            let mossCol = lerpColor('#6a7a48', hz, hazeFactor);
            // Shadow
            ctx.fillStyle = 'rgba(0,0,0,0.15)';
            ctx.fillRect(Math.round(sx-3*scale), Math.round(sy+2.5*scale), Math.round(7*scale), Math.round(scale));
            // Main body (roughly rounded)
            drawRect(sx-3*scale, sy-1*scale, 6*scale, 3.5*scale, baseCol);
            drawRect(sx-2.5*scale, sy-2*scale, 5*scale, scale, baseCol);
            drawRect(sx-2*scale, sy-2.5*scale, 4*scale, scale, baseCol);
            // Dark underside
            drawRect(sx-3*scale, sy+1.5*scale, 6*scale, scale, darkCol);
            // Light top
            drawRect(sx-2*scale, sy-2*scale, 3.5*scale, scale, lightCol);
            // Highlight
            ctx.globalAlpha = 0.4;
            drawRect(sx-1.5*scale, sy-2.5*scale, 2*scale, scale, highlightCol);
            ctx.globalAlpha = 1;
            // Moss patches
            let seed = boulder.seed;
            if (Math.sin(seed * 3.7) > 0) {
                drawRect(sx-2*scale, sy+0.5*scale, 2*scale, scale, mossCol);
            }
            if (Math.sin(seed * 7.3) > 0.2) {
                drawRect(sx+1*scale, sy-0.5*scale, 1.5*scale, scale*0.8, mossCol);
            }
            // Crack detail
            drawRect(sx-0.5*scale, sy-1.5*scale, Math.max(1,0.3*scale), 2*scale, darkCol);
        }

        function drawBench(sx, sy, scale, bench, relZ) {
            scale *= 3.5;
            let hazeFactor = getTreeHazeFactor(relZ);
            let hz = PALETTE.hazeColor;
            let woodCol = lerpColor('#8a6a40', hz, hazeFactor);
            let woodDark = lerpColor('#6a4a28', hz, hazeFactor);
            let woodLight = lerpColor('#a88a58', hz, hazeFactor);
            let legCol = lerpColor('#5a4028', hz, hazeFactor);
            let bw = 6; // half-width of bench
            // Shadow
            ctx.fillStyle = 'rgba(0,0,0,0.15)';
            ctx.fillRect(Math.round(sx-bw*scale), Math.round(sy+4*scale), Math.round(bw*2*scale), Math.round(scale));
            // Legs (4 legs — spread wide)
            drawRect(sx-(bw-0.5)*scale, sy+1*scale, scale, 3*scale, legCol);
            drawRect(sx+(bw-1.5)*scale, sy+1*scale, scale, 3*scale, legCol);
            drawRect(sx-2*scale, sy+1*scale, scale, 3*scale, legCol);
            drawRect(sx+1*scale, sy+1*scale, scale, 3*scale, legCol);
            // Seat (horizontal planks — wide)
            drawRect(sx-bw*scale, sy-0.5*scale, bw*2*scale, 1.5*scale, woodCol);
            drawRect(sx-bw*scale, sy-0.5*scale, bw*2*scale, scale*0.5, woodLight);
            // Plank lines
            drawRect(sx-bw*scale, sy+0.2*scale, bw*2*scale, Math.max(1, 0.2*scale), woodDark);
            drawRect(sx-bw*scale, sy-0.1*scale, bw*2*scale, Math.max(1, 0.15*scale), woodDark);
            // Armrests
            drawRect(sx-(bw-0.3)*scale, sy-1.5*scale, scale*1.2, scale, woodCol);
            drawRect(sx+(bw-1.5)*scale, sy-1.5*scale, scale*1.2, scale, woodCol);
            // Backrest posts
            drawRect(sx-(bw-0.5)*scale, sy-4*scale, scale*1.2, 4.5*scale, legCol);
            drawRect(sx+(bw-1.5)*scale, sy-4*scale, scale*1.2, 4.5*scale, legCol);
            // Backrest slats
            drawRect(sx-bw*scale, sy-3.5*scale, bw*2*scale, scale, woodCol);
            drawRect(sx-bw*scale, sy-2*scale, bw*2*scale, scale, woodCol);
            // Backrest highlights
            drawRect(sx-bw*scale, sy-3.5*scale, bw*2*scale, scale*0.3, woodLight);
            drawRect(sx-bw*scale, sy-2*scale, bw*2*scale, scale*0.3, woodLight);
        }

        function drawFisher(sx, sy, scale, fisher, relZ) {
            scale *= 3.5;
            let hazeFactor = getTreeHazeFactor(relZ);
            let hz = PALETTE.hazeColor;
            let skinCol = lerpColor('#e8b888', hz, hazeFactor);
            let hairCol = lerpColor(fisher.hairColor, hz, hazeFactor);
            let shirtCol = lerpColor(fisher.shirtColor, hz, hazeFactor);
            let pantsCol = lerpColor(fisher.pantsColor, hz, hazeFactor);
            let shoeCol = lerpColor('#3a2a1a', hz, hazeFactor);
            let hatCol = lerpColor(fisher.hatColor, hz, hazeFactor);
            let rodCol = lerpColor('#7a5a30', hz, hazeFactor);
            let rodTip = lerpColor('#a08050', hz, hazeFactor);
            let lineCol = lerpColor('#c0c0c0', hz, hazeFactor);
            let py = (x,y,w,h,color) => { drawRect(sx+x*scale, sy+y*scale, w*scale, h*scale, color); };
            // Shadow
            ctx.fillStyle = 'rgba(0,0,0,0.15)';
            ctx.fillRect(Math.round(sx-2*scale), Math.round(sy+4*scale), Math.round(5*scale), Math.round(scale));
            // Legs (seated — extended forward)
            py(-2, 2, 1.5, 2, pantsCol);
            py(0.5, 2, 1.5, 2, pantsCol);
            py(-2, 3.5, 1.5, 1, shoeCol);
            py(0.5, 3.5, 1.5, 1, shoeCol);
            // Body (seated posture — slightly leaned forward)
            py(-2.5, -3, 5, 5, shirtCol);
            // Arms — one holding rod, one resting
            py(-3.5, -2, 1.5, 3, shirtCol);
            py(2, -2.5, 1.5, 3.5, shirtCol); // rod arm reaching up
            // Hands
            py(-3.5, 0.5, scale*0.3, scale*0.3, skinCol);
            py(2.5, -2.5, scale*0.3, scale*0.3, skinCol);
            // Head
            py(-1.5, -6, 3, 3, skinCol);
            // Hat (bucket/fishing hat)
            py(-2.5, -7, 5, 1.5, hatCol);
            py(-1.5, -8, 3, 1.5, hatCol);
            // Hair
            py(-1.5, -6.5, 3, 0.5, hairCol);
            // Fishing rod — angled out to the right toward the water
            let rodSway = Math.sin(time * 0.002 + fisher.rodOffset) * 0.3;
            // Rod drawn as series of pixels from hand to tip, angling right and up
            let rodSegs = 12;
            let handX = sx+2.5*scale, handY = sy-2.5*scale;
            let tipX = handX + 18*scale, tipY = handY - 8*scale + rodSway*scale;
            for (let r = 0; r < rodSegs; r++) {
                let t = r / rodSegs;
                let rx = Math.round(handX + (tipX-handX)*t);
                let ry = Math.round(handY + (tipY-handY)*t - Math.sin(t*Math.PI)*2*scale);
                let rw = Math.max(1, Math.round((1-t*0.5)*scale*0.5));
                ctx.fillStyle = t < 0.85 ? rodCol : rodTip;
                ctx.fillRect(rx, ry, rw, Math.max(1, rw));
            }
            // Fishing line — curves from rod tip down to water surface
            ctx.fillStyle = lineCol;
            let bobberSway = Math.sin(time * 0.001 + fisher.rodOffset) * 2;
            let waterX = tipX + 12*scale + bobberSway*scale;
            let waterY = sy + 3*scale; // roughly water surface level
            let lineSegs = 16;
            for (let l = 0; l < lineSegs; l++) {
                let t = l / lineSegs;
                // Catenary-like curve: starts at tip, arcs down to water
                let lx = Math.round(tipX + (waterX-tipX)*t);
                let ly = Math.round(tipY + (waterY-tipY)*t*t + (1-t)*Math.sin(t*Math.PI)*(-3*scale));
                ctx.fillRect(lx, ly, 1, 1);
            }
            // Bobber on the water
            let bobberCol = lerpColor('#e84848', hz, hazeFactor);
            let bobberWhite = lerpColor('#f0f0e0', hz, hazeFactor);
            let bx = Math.round(waterX), by = Math.round(waterY);
            let bobFloat = Math.sin(time*0.003 + fisher.rodOffset)*scale*0.3;
            drawRect(bx-Math.round(scale*0.4), by+bobFloat, Math.max(2, Math.round(scale)), Math.max(2, Math.round(scale*1.2)), bobberCol);
            drawRect(bx-Math.round(scale*0.2), by+bobFloat+Math.round(scale*0.7), Math.max(1, Math.round(scale*0.6)), Math.max(1, Math.round(scale*0.5)), bobberWhite);
        }

        function drawSailboat(sx, sy, scale, boat, relZ) {
            scale *= 4;
            let hazeFactor = getTreeHazeFactor(relZ);
            let hz = PALETTE.hazeColor;
            let s = scale;
            let bob = Math.sin(time * 0.0006 + boat.bobSeed) * 2 * s;
            let tilt = Math.sin(time * 0.0004 + boat.bobSeed + 1.0) * 0.5;
            let bsy = Math.round(sy + bob);

            // Hull
            let hullW = Math.max(4, Math.round(12 * s));
            let hullH = Math.max(2, Math.round(3 * s));
            let hullX = Math.round(sx - hullW / 2);
            let hullCol = lerpColor(boat.hullColor, hz, hazeFactor);
            let hullDark = lerpColor('#3a2518', hz, hazeFactor);
            let hullTrim = lerpColor('#c8b090', hz, hazeFactor);
            // Hull body — slightly tapered (wider at top)
            ctx.fillStyle = hullCol;
            ctx.fillRect(hullX, bsy, hullW, hullH);
            // Tapered bottom
            ctx.fillRect(hullX + Math.round(s), bsy + hullH, hullW - Math.round(2 * s), Math.max(1, Math.round(s)));
            // Dark waterline
            ctx.fillStyle = hullDark;
            ctx.fillRect(hullX, bsy + hullH - Math.max(1, Math.round(s * 0.5)), hullW, Math.max(1, Math.round(s * 0.5)));
            // Trim stripe
            ctx.fillStyle = hullTrim;
            ctx.fillRect(hullX, bsy + Math.max(1, Math.round(s * 0.5)), hullW, Math.max(1, Math.round(s * 0.5)));

            // Mast
            let mastH = Math.max(5, Math.round(14 * s));
            let mastW = Math.max(1, Math.round(s));
            let mastX = Math.round(sx + tilt * s);
            let mastCol = lerpColor('#5a4030', hz, hazeFactor);
            ctx.fillStyle = mastCol;
            ctx.fillRect(mastX, bsy - mastH, mastW, mastH);

            // Sail — triangle
            let sailW = Math.max(3, Math.round(8 * s));
            let sailH = Math.max(4, Math.round(11 * s));
            let sailCol = lerpColor('#f8f4ec', hz, hazeFactor);
            let sailShade = lerpColor('#e0d8c8', hz, hazeFactor);
            let sailTop = bsy - mastH + Math.round(s);
            // Wind billowing effect
            let billowOff = Math.sin(time * 0.0005 + boat.bobSeed) * 2 * s;
            // Draw sail as tapered rows
            for (let r = 0; r < sailH; r++) {
                let frac = r / sailH;
                let rw = Math.max(1, Math.round(sailW * frac));
                let rx = mastX + Math.round(billowOff * frac) + mastW;
                ctx.fillStyle = frac < 0.5 ? sailCol : sailShade;
                ctx.fillRect(rx, sailTop + r, rw, 1);
            }

            // Small flag at top
            let flagCol = lerpColor(boat.flagColor, hz, hazeFactor);
            ctx.fillStyle = flagCol;
            ctx.fillRect(mastX + mastW, bsy - mastH, Math.max(2, Math.round(3 * s)), Math.max(1, Math.round(s)));
            ctx.fillRect(mastX + mastW, bsy - mastH + Math.max(1, Math.round(s)), Math.max(1, Math.round(2 * s)), Math.max(1, Math.round(s)));

            // Water reflection under hull
            ctx.globalAlpha = 0.2;
            ctx.fillStyle = hullCol;
            ctx.fillRect(hullX + Math.round(s), bsy + hullH + Math.round(s), hullW - Math.round(2 * s), Math.max(1, Math.round(s)));
            ctx.globalAlpha = 1;
        }

        // ===== AUDIO SYSTEM =====
        let audioCtx = null;
        let audioInitialized = false;
        let audioPlaying = false;
        let audioChannels = {
            music: { gain: null, volume: 0.5, nodes: [] },
            wind: { gain: null, volume: 0.2, nodes: [] },
            birds: { gain: null, volume: 0.3, nodes: [] },
            footsteps: { gain: null, volume: 0.4, nodes: [] },
            sheep: { gain: null, volume: 0.08, nodes: [] }
        };

        function initAudio() {
            audioCtx = new (window.AudioContext || window.webkitAudioContext)();

            // Create gain nodes for each channel
            for (let key in audioChannels) {
                audioChannels[key].gain = audioCtx.createGain();
                audioChannels[key].gain.gain.value = audioChannels[key].volume;
                audioChannels[key].gain.connect(audioCtx.destination);
            }

            initLofiMusic();
            initWind();
            initBirds();
            initSheep();
            audioInitialized = true;
            audioPlaying = true;
        }

        // Music: Load and loop MP3 track
        async function initLofiMusic() {
            try {
                const resp = await fetch('morning-reset.mp3');
                const arr = await resp.arrayBuffer();
                const buf = await audioCtx.decodeAudioData(arr);
                const source = audioCtx.createBufferSource();
                source.buffer = buf;
                source.loop = true;
                source.connect(audioChannels.music.gain);
                source.start();
                audioChannels.music.nodes.push(source);
            } catch(e) { console.warn('Could not load music track:', e); }
        }

        // Wind: Brown noise through modulated low-pass filter
        function initWind() {
            const bufferSize = audioCtx.sampleRate * 2;
            const buffer = audioCtx.createBuffer(1, bufferSize, audioCtx.sampleRate);
            const data = buffer.getChannelData(0);

            let lastOut = 0;
            for (let i = 0; i < bufferSize; i++) {
                let white = Math.random() * 2 - 1;
                data[i] = (lastOut + (0.02 * white)) / 1.02;
                lastOut = data[i];
                data[i] *= 3.5;
            }

            const source = audioCtx.createBufferSource();
            source.buffer = buffer;
            source.loop = true;

            const filter = audioCtx.createBiquadFilter();
            filter.type = 'lowpass';
            filter.frequency.value = 400;
            filter.Q.value = 0.5;

            // LFO for gusting effect
            const lfo = audioCtx.createOscillator();
            const lfoGain = audioCtx.createGain();
            lfo.type = 'sine';
            lfo.frequency.value = 0.15;
            lfoGain.gain.value = 300;
            lfo.connect(lfoGain);
            lfoGain.connect(filter.frequency);
            lfo.start();

            const windGain = audioCtx.createGain();
            windGain.gain.value = 0.3;

            source.connect(filter);
            filter.connect(windGain);
            windGain.connect(audioChannels.wind.gain);

            source.start();
            audioChannels.wind.nodes.push(source, lfo);
        }

        // Birds: Periodic sine-wave chirps
        function initBirds() {
            function chirp() {
                if (!audioCtx || audioCtx.state === 'closed' || !audioPlaying) return;

                const now = audioCtx.currentTime;
                const noteCount = 2 + Math.floor(Math.random() * 3);

                for (let i = 0; i < noteCount; i++) {
                    const osc = audioCtx.createOscillator();
                    const oscGain = audioCtx.createGain();

                    osc.type = 'sine';
                    const baseFreq = 2000 + Math.random() * 2000;
                    const noteStart = now + i * 0.12;
                    const noteDuration = 0.06 + Math.random() * 0.06;

                    osc.frequency.setValueAtTime(baseFreq, noteStart);
                    osc.frequency.linearRampToValueAtTime(
                        baseFreq * (1 + (Math.random() - 0.5) * 0.3),
                        noteStart + noteDuration
                    );

                    oscGain.gain.setValueAtTime(0, noteStart);
                    oscGain.gain.linearRampToValueAtTime(0.06, noteStart + 0.01);
                    oscGain.gain.linearRampToValueAtTime(0, noteStart + noteDuration);

                    osc.connect(oscGain);
                    oscGain.connect(audioChannels.birds.gain);

                    osc.start(noteStart);
                    osc.stop(noteStart + noteDuration + 0.01);
                }

                setTimeout(chirp, 3000 + Math.random() * 5000);
            }

            setTimeout(chirp, 1000 + Math.random() * 2000);
        }

        // Sheep: Sample-based bleating from recorded audio files
        let sheepBuffers = [];
        async function initSheep() {
            const files = ['sheep.mp3', 'sheep2.mp3', 'sheep3.mp3'];
            for (const file of files) {
                try {
                    const resp = await fetch(file);
                    const arr = await resp.arrayBuffer();
                    const buf = await audioCtx.decodeAudioData(arr);
                    sheepBuffers.push(buf);
                } catch(e) { /* skip failed loads */ }
            }
            if (sheepBuffers.length > 0) {
                scheduleBaa();
            }
        }
        function scheduleBaa() {
            setTimeout(() => {
                if (!audioCtx || audioCtx.state === 'closed' || !audioPlaying) {
                    scheduleBaa();
                    return;
                }
                const buf = sheepBuffers[Math.floor(Math.random() * sheepBuffers.length)];
                const source = audioCtx.createBufferSource();
                source.buffer = buf;
                // Slight pitch variation for natural feel
                source.playbackRate.value = 0.9 + Math.random() * 0.2;
                source.connect(audioChannels.sheep.gain);
                source.start();
                scheduleBaa();
            }, 8000 + Math.random() * 12000);
        }

        // Footsteps: Noise bursts synced to walk phase
        let lastFootstepPhase = 0;
        function updateFootsteps() {
            if (!audioCtx || !audioInitialized || !audioPlaying) return;

            let walkPhase = time * 0.014;
            let currentPhase = Math.sin(walkPhase);

            if ((lastFootstepPhase >= 0 && currentPhase < 0) || (lastFootstepPhase <= 0 && currentPhase > 0)) {
                const now = audioCtx.currentTime;
                const sampleLen = Math.floor(audioCtx.sampleRate * 0.14);
                const buffer = audioCtx.createBuffer(1, sampleLen, audioCtx.sampleRate);
                const data = buffer.getChannelData(0);

                // Soft, muted envelope - like stepping on grass/dirt
                for (let i = 0; i < sampleLen; i++) {
                    const t = i / sampleLen;
                    // Slow attack, gradual decay for a soft thud
                    const attack = Math.min(1, t / 0.08);
                    const decay = Math.exp(-i / (sampleLen * 0.35));
                    const env = attack * decay;
                    data[i] = (Math.random() * 2 - 1) * env * 0.25;
                }

                const source = audioCtx.createBufferSource();
                source.buffer = buffer;

                // Very low cutoff for muffled ground-step sound
                const filter = audioCtx.createBiquadFilter();
                filter.type = 'lowpass';
                filter.frequency.value = 180 + Math.random() * 80;
                filter.Q.value = 0.3;

                // Second filter pass for extra muffling
                const filter2 = audioCtx.createBiquadFilter();
                filter2.type = 'lowpass';
                filter2.frequency.value = 350;
                filter2.Q.value = 0.4;

                source.connect(filter);
                filter.connect(filter2);
                filter2.connect(audioChannels.footsteps.gain);

                source.start(now);
            }

            lastFootstepPhase = currentPhase;
        }

        // Audio UI logic
        function setupAudioUI() {
            const toggleBtn = document.getElementById('audio-toggle');
            const panel = document.getElementById('audio-panel');

            toggleBtn.addEventListener('click', () => {
                if (!audioInitialized) {
                    initAudio();
                    toggleBtn.textContent = '\u266B Sound';
                }
                panel.classList.toggle('open');
            });

            document.querySelectorAll('.audio-slider input[type="range"]').forEach(slider => {
                slider.addEventListener('input', (e) => {
                    const channel = e.target.dataset.channel;
                    const value = e.target.value / 100;
                    audioChannels[channel].volume = value;
                    if (audioChannels[channel].gain) {
                        audioChannels[channel].gain.gain.value = value;
                    }
                });
            });
        }

        function init() {
            resize(); window.addEventListener('resize', resize);
            const TREE_COUNT = 15;
            // Pre-generate spaced x positions to avoid clumping
            let treeXPositions = [];
            for (let i=0; i<TREE_COUNT; i++) {
                let attempts = 0, tx;
                do {
                    tx = getRandomTreeX();
                    attempts++;
                } while (attempts < 20 && treeXPositions.some(px => Math.abs(px - tx) < 120));
                treeXPositions.push(tx);
            }
            for (let i=0; i<TREE_COUNT; i++) {
                entities.push({
                    type:'tree',
                    x: treeXPositions[i],
                    y:CAMERA_Y,
                    z: (i / TREE_COUNT) * MAX_Z + Math.random() * (MAX_Z / TREE_COUNT),
                    variant:Math.floor(Math.random()*6),
                    hScale:0.5+Math.random()*1.2
                });
            }
            // 3D grass tufts removed — foreground detail covers close-range grass
            for (let i=0; i<80; i++) {
                let leaf={type:'leaf'}; resetLeaf(leaf); leaf.y+=Math.random()*100; entities.push(leaf);
            }

            // Create ground leaf clusters
            let groundLeaves = createGroundLeaves();
            groundLeaves.forEach(gl => entities.push(gl));

            // Create scrolling home entities
            let homeStyles = [
                { wall: '#c4a87a', wallDark: '#a8906a', roof: '#8b3a3a', roofDark: '#6e2828', door: '#5a3820' },
                { wall: '#d4b898', wallDark: '#b89878', roof: '#6e2e2e', roofDark: '#521e1e', door: '#4a2818' },
                { wall: '#e0d0b8', wallDark: '#c4b098', roof: '#7a4030', roofDark: '#5c2e22', door: '#6a4030' },
                { wall: '#b89868', wallDark: '#9a7a50', roof: '#5a2828', roofDark: '#401818', door: '#3a2010' },
                { wall: '#c8a070', wallDark: '#a88858', roof: '#944040', roofDark: '#742828', door: '#5a3828' },
                { wall: '#dcc8a8', wallDark: '#c0a880', roof: '#704038', roofDark: '#582828', door: '#4a3020' },
            ];
            let HOME_COUNT = 3 + Math.floor(Math.random() * 3); // 3-5
            for (let i = 0; i < HOME_COUNT; i++) {
                let style = homeStyles[Math.floor(Math.random() * homeStyles.length)];
                let hasCh = Math.random() > 0.3;
                entities.push({
                    type: 'home',
                    homeType: Math.floor(Math.random() * 3), // 0=cottage, 1=tall, 2=barn
                    x: getRandomHomeX(),
                    y: CAMERA_Y,
                    z: (i / HOME_COUNT) * MAX_Z + Math.random() * (MAX_Z / HOME_COUNT),
                    wallColor: style.wall,
                    wallDarkColor: style.wallDark,
                    roofColor: style.roof,
                    roofDarkColor: style.roofDark,
                    doorColor: style.door,
                    hasChimney: hasCh,
                    hasSmoke: hasCh && Math.random() > 0.3,
                    hasFence: Math.random() > 0.45,
                    smokeSeed: Math.random() * 100,
                });
            }

            // Sailboats on the lake
            let hullColors = ['#6a4030', '#5a3828', '#7a5040', '#4a3020', '#8a6050'];
            let flagColors = ['#e84848', '#4878c8', '#e8c840', '#48a868', '#f0f0e0'];
            let BOAT_COUNT = 2 + Math.floor(Math.random() * 2); // 2-3
            for (let i = 0; i < BOAT_COUNT; i++) {
                entities.push({
                    type: 'boat',
                    x: 800 + Math.random() * 500, // on the water (right side)
                    y: CAMERA_Y,
                    z: 200 + Math.random() * (MAX_Z - 400),
                    hullColor: hullColors[Math.floor(Math.random() * hullColors.length)],
                    flagColor: flagColors[Math.floor(Math.random() * flagColors.length)],
                    bobSeed: Math.random() * 100,
                });
            }

            // People walking near homes
            let shirtColors = ['#c85040', '#4878a8', '#6a9a50', '#c8a040', '#8860a0', '#d07848'];
            let pantsColors = ['#3a4a6a', '#5a4a3a', '#4a5a3a', '#6a5a4a'];
            let hairColors = ['#2c1e16', '#5a3a20', '#8a6a40', '#1a1410', '#6a4a30'];
            let PERSON_COUNT = 8 + Math.floor(Math.random() * 5); // 8-12
            for (let i = 0; i < PERSON_COUNT; i++) {
                entities.push({
                    type: 'person',
                    x: getRandomHomeX(),
                    y: CAMERA_Y,
                    z: Math.random() * MAX_Z,
                    shirtColor: shirtColors[Math.floor(Math.random() * shirtColors.length)],
                    pantsColor: pantsColors[Math.floor(Math.random() * pantsColors.length)],
                    hairColor: hairColors[Math.floor(Math.random() * hairColors.length)],
                    walkOffset: Math.random() * 100,
                });
            }

            // Ground sheep in clumps
            let CLUMP_COUNT = 6 + Math.floor(Math.random() * 4); // 6-9 clumps
            for (let c = 0; c < CLUMP_COUNT; c++) {
                let clumpX = getRandomTreeX();
                let clumpZ = Math.random() * MAX_Z;
                let sheepInClump = 2 + Math.floor(Math.random() * 2); // 2-3 per clump
                for (let s = 0; s < sheepInClump; s++) {
                    entities.push({
                        type: 'sheep',
                        x: clumpX + (Math.random() - 0.5) * 80,
                        y: CAMERA_Y,
                        z: clumpZ + (Math.random() - 0.5) * 60,
                        eatOffset: Math.random() * 100,
                        walkOffset: Math.random() * 100,
                        facing: Math.random() > 0.5 ? 1 : -1,
                        clumpId: c,
                    });
                }
            }

            // Cows near homes
            let cowBodyColors = [
                { body: '#f0ece0', patch: '#4a3020', head: '#4a3020' }, // white with dark patches
                { body: '#c89060', patch: '#f0ece0', head: '#6a4830' }, // brown with white patches
                { body: '#f0ece0', patch: '#8a6840', head: '#6a4830' }, // white with brown patches
                { body: '#3a2a1a', patch: '#f0ece0', head: '#2a1a10' }, // dark with white patches
            ];
            let COW_COUNT = 4 + Math.floor(Math.random() * 3); // 4-6
            for (let i = 0; i < COW_COUNT; i++) {
                let cowColor = cowBodyColors[Math.floor(Math.random() * cowBodyColors.length)];
                entities.push({
                    type: 'cow',
                    x: getRandomHomeX(),
                    y: CAMERA_Y,
                    z: Math.random() * MAX_Z,
                    bodyColor: cowColor.body,
                    patchColor: cowColor.patch,
                    headColor: cowColor.head,
                    facing: Math.random() > 0.5 ? 1 : -1,
                    walkOffset: Math.random() * 100,
                });
            }

            // Shepherds near sheep clumps (one per 2-3 clumps)
            let shepherdShirts = ['#7a6848', '#5a6a48', '#8a7858', '#6a5a40'];
            let shepherdPants = ['#4a3a28', '#3a4a3a', '#5a4a38'];
            let shepherdHair = ['#4a3828', '#2c1e16', '#6a5a40', '#8a7a60'];
            let SHEPHERD_COUNT = Math.floor(CLUMP_COUNT / 2.5) + 1; // ~3-4 shepherds
            for (let i = 0; i < SHEPHERD_COUNT; i++) {
                let clumpIdx = Math.floor(i * CLUMP_COUNT / SHEPHERD_COUNT);
                // Find a sheep from that clump to place shepherd near
                let sheepOfClump = entities.filter(e => e.type === 'sheep' && e.clumpId === clumpIdx);
                let refSheep = sheepOfClump.length > 0 ? sheepOfClump[0] : null;
                entities.push({
                    type: 'shepherd',
                    x: refSheep ? refSheep.x + (Math.random()-0.5)*60 : getRandomTreeX(),
                    y: CAMERA_Y,
                    z: refSheep ? refSheep.z + (Math.random()-0.5)*40 : Math.random() * MAX_Z,
                    shirtColor: shepherdShirts[Math.floor(Math.random() * shepherdShirts.length)],
                    pantsColor: shepherdPants[Math.floor(Math.random() * shepherdPants.length)],
                    hairColor: shepherdHair[Math.floor(Math.random() * shepherdHair.length)],
                    walkOffset: Math.random() * 100,
                    clumpId: clumpIdx,
                });
            }

            // Benches with fishers near the water edge
            let hatColors = ['#6a7a48', '#7a6848', '#5a6860', '#8a7a58'];
            let fisherShirts = ['#5a7a48', '#7a6040', '#4a6878', '#8a7050', '#6a5a48'];
            let fisherPants = ['#4a5a3a', '#5a4a3a', '#3a4a5a', '#6a5a40'];
            let fisherHair2 = ['#3a2a1a', '#5a4a30', '#7a6a48', '#1a1410'];
            let BENCH_COUNT = 1 + Math.floor(Math.random() * 2); // 1-2
            for (let i = 0; i < BENCH_COUNT; i++) {
                let benchX = 480 + Math.random() * 100; // near the water edge
                let benchZ = (i / BENCH_COUNT) * MAX_Z + Math.random() * (MAX_Z / BENCH_COUNT);
                entities.push({
                    type: 'bench',
                    x: benchX,
                    y: CAMERA_Y,
                    z: benchZ,
                });
                // Fisher sitting on the bench
                entities.push({
                    type: 'fisher',
                    x: benchX + 2, // slightly offset to sit on bench
                    y: CAMERA_Y,
                    z: benchZ + 1, // just in front of bench
                    shirtColor: fisherShirts[Math.floor(Math.random() * fisherShirts.length)],
                    pantsColor: fisherPants[Math.floor(Math.random() * fisherPants.length)],
                    hairColor: fisherHair2[Math.floor(Math.random() * fisherHair2.length)],
                    hatColor: hatColors[Math.floor(Math.random() * hatColors.length)],
                    rodOffset: Math.random() * 100,
                });
            }

            for (let i=0; i<6; i++) {
                clouds.push({ x:Math.random()*canvas.width, y:Math.random()*(HORIZON-50), w:40+Math.random()*80, h:15+Math.random()*20, speed:0.02+Math.random()*0.03 });
            }
            for (let i=0; i<5; i++) {
                let birdY = 10+Math.random()*(HORIZON*0.7);
                let birdSize = birdY > HORIZON*0.4 ? 1.5+Math.random()*1.5 : 1; // closer = bigger
                birds.push({ x:Math.random()*canvas.width, y:birdY, offset:Math.random()*100, size:birdSize });
            }

            setupAudioUI();
            requestAnimationFrame(loop);
        }

        function drawRect(x,y,w,h,color) { ctx.fillStyle=color; ctx.fillRect(Math.round(x),Math.round(y),Math.round(w),Math.round(h)); }

        function drawBackground() {
            let bandH=HORIZON/PALETTE.skyBands.length;
            PALETTE.skyBands.forEach((color,i)=>{ drawRect(0,i*bandH,canvas.width,bandH+2,color); });
            // Sun — circular with wide glow layers
            let sunCX = canvas.width*0.75 + 14, sunCY = HORIZON*0.15 + 14;
            // Helper: draw a filled pixel circle
            function sunDisc(cx2,cy2,r,color,alpha) {
                ctx.globalAlpha = alpha;
                ctx.fillStyle = color;
                for (let dy=-r; dy<=r; dy++) {
                    let dx = Math.floor(Math.sqrt(r*r - dy*dy));
                    ctx.fillRect(Math.round(cx2-dx), Math.round(cy2+dy), dx*2+1, 1);
                }
            }
            // Widest ambient wash
            sunDisc(sunCX, sunCY, 48, '#fff8e0', 0.06);
            // Second ambient
            sunDisc(sunCX, sunCY, 38, '#fff0c8', 0.1);
            // Outermost glow
            sunDisc(sunCX, sunCY, 30, PALETTE.sunGlow, 0.15);
            // Soft halo
            sunDisc(sunCX, sunCY, 24, PALETTE.sunGlow, 0.25);
            // Mid glow
            sunDisc(sunCX, sunCY, 18, PALETTE.sunOuter, 0.4);
            // Warm middle
            sunDisc(sunCX, sunCY, 14, PALETTE.sunMid, 0.6);
            // Inner warm
            sunDisc(sunCX, sunCY, 11, PALETTE.sunMid, 0.8);
            // Bright core
            sunDisc(sunCX, sunCY, 9, PALETTE.sun, 1.0);
            // Hot center
            sunDisc(sunCX, sunCY, 6, '#ffe880', 1.0);
            // White-hot center
            sunDisc(sunCX, sunCY, 3, '#fff8e8', 0.7);
            ctx.globalAlpha = 1;

            clouds.forEach(c => {
                c.x+=c.speed; if (c.x>canvas.width+c.w) c.x=-c.w;
                // Soft outer shadow (beneath)
                ctx.globalAlpha = 0.25;
                drawRect(c.x+c.w*0.08,c.y+c.h*0.5,c.w*0.88,c.h*0.6,'#c8c0b8');
                ctx.globalAlpha = 1;
                // Main shadow layer
                drawRect(c.x+c.w*0.05,c.y+c.h*0.35,c.w*0.9,c.h*0.7,PALETTE.cloudShadow);
                // Base volumes — three overlapping puffs
                drawRect(c.x,c.y,c.w,c.h,PALETTE.cloudBase);
                drawRect(c.x+c.w*0.1,c.y-c.h*0.3,c.w*0.5,c.h*0.9,PALETTE.cloudBase);
                drawRect(c.x+c.w*0.35,c.y-c.h*0.55,c.w*0.45,c.h*1.15,PALETTE.cloudBase);
                // Extra small puff on the right
                drawRect(c.x+c.w*0.65,c.y-c.h*0.15,c.w*0.3,c.h*0.7,PALETTE.cloudBase);
                // Midtone detail — subtle form between shadow and highlight
                drawRect(c.x+c.w*0.05,c.y+c.h*0.15,c.w*0.6,c.h*0.35,'#e8e6e4');
                // Top highlights — bright lit tops
                drawRect(c.x+2,c.y+2,c.w*0.85,c.h*0.3,PALETTE.cloudLight);
                drawRect(c.x+c.w*0.12+2,c.y-c.h*0.28,c.w*0.38,c.h*0.35,PALETTE.cloudLight);
                drawRect(c.x+c.w*0.38+2,c.y-c.h*0.52,c.w*0.3,c.h*0.35,PALETTE.cloudLight);
                // Warm sun-facing highlight on the right puffs
                ctx.globalAlpha = 0.3;
                drawRect(c.x+c.w*0.55,c.y-c.h*0.4,c.w*0.2,c.h*0.4,'#fff8e8');
                ctx.globalAlpha = 1;
            });

            // SNOW-CAPPED DUAL-PEAK MOUNTAIN (behind far hills, left side)
            {
                let hz = PALETTE.hazeColor;
                let mtnHaze = 0.12; // minimal haze — keep it very white
                let snowColor = lerpColor('#f4f7fa', hz, mtnHaze);
                let snowShade = lerpColor('#e4eaf2', hz, mtnHaze);
                let snowBright = lerpColor('#ffffff', hz, mtnHaze * 0.3);
                let snowDark = lerpColor('#d4dce8', hz, mtnHaze);
                let ridgeColor = lerpColor('#c0cad6', hz, mtnHaze);
                let mtnBase = HORIZON - 2;
                // Two peaks: wider spread, larger on left, smaller on right
                let pk1x = canvas.width * 0.17, pk1h = HORIZON * 0.58;
                let pk2x = canvas.width * 0.32, pk2h = HORIZON * 0.40;
                let mtnLeft = canvas.width * 0.01;
                let mtnRight = canvas.width * 0.48;
                // Natural mountain profile: wide smooth base + gentle undulation
                function mtnProfile(px) {
                    let d1 = Math.abs(px - pk1x) / (canvas.width * 0.22); // wider base
                    let h1 = d1 < 1 ? pk1h * Math.pow(1 - d1, 1.2) * (1 - d1 * 0.2) : 0;
                    let d2 = Math.abs(px - pk2x) / (canvas.width * 0.16); // wider base
                    let h2 = d2 < 1 ? pk2h * Math.pow(1 - d2, 1.2) * (1 - d2 * 0.2) : 0;
                    let base = Math.max(h1, h2);
                    if (base < 1) return 0;
                    // Gentle natural undulation (low frequency, small amplitude)
                    let undulate = Math.sin(px * 0.08) * 1.5 + Math.sin(px * 0.19) * 1;
                    return Math.max(0, base + undulate);
                }
                // Draw column by column — entirely snow-covered
                for (let px = Math.round(mtnLeft); px <= Math.round(mtnRight); px++) {
                    let h = mtnProfile(px);
                    if (h < 1) continue;
                    let topY = Math.round(mtnBase - h);
                    // Shading: left side shadow, right side lit
                    let d1 = (px - pk1x) / (canvas.width * 0.16);
                    let d2 = (px - pk2x) / (canvas.width * 0.12);
                    let isLeftSide = Math.abs(d1) < Math.abs(d2) ? d1 < 0 : d2 < 0;
                    // Subtle ridge texture from slope changes
                    let hPrev = mtnProfile(px - 2), hNext = mtnProfile(px + 2);
                    let slope = (hNext - hPrev) * 0.5;
                    for (let my = topY; my <= mtnBase; my++) {
                        let distFromTop = my - topY;
                        let totalH = mtnBase - topY;
                        if (isLeftSide) {
                            ctx.fillStyle = distFromTop < 2 ? snowDark : snowShade;
                        } else {
                            ctx.fillStyle = distFromTop < 2 ? snowBright : snowColor;
                        }
                        // Subtle ridge lines from slope variation
                        if (Math.abs(slope) > 1.2 && distFromTop < 3) {
                            ctx.fillStyle = ridgeColor;
                        }
                        ctx.fillRect(px, my, 1, 1);
                    }
                    // Bright peak highlight
                    if (!isLeftSide) {
                        ctx.fillStyle = snowBright;
                        ctx.fillRect(px, topY, 1, 1);
                    }
                }
            }

            // FAR HILLS
            mountains.far.forEach(m => {
                fillHillWithVerticalFade(m, PALETTE.hillFar, HAZE_FAR);
                drawHillPatches(m, PALETTE.hillFarLight, PALETTE.hillFarShadow, PALETTE.hillFarLight, HAZE_FAR);
                drawTreeLine(m, PALETTE.hillFarTree, 0.55, 3, HAZE_FAR);
            });

            // MID HILLS
            mountains.mid.forEach(m => {
                fillHillWithVerticalFade(m, PALETTE.hillMid, HAZE_MID);
                drawHillPatches(m, PALETTE.hillMidLight, PALETTE.hillMidShadow, PALETTE.hillMidField, HAZE_MID);
                drawHedgeRow(m, PALETTE.hillMidShadow, HAZE_MID);
                drawTreeLine(m, PALETTE.hillMidTree, 0.45, 4, HAZE_MID);
                drawStaticHomes(m, '#c4a87a', '#8b3a3a', HAZE_MID, 2);
            });
            // Mid-hill sheep (smaller, haze-tinted)
            let midSheepBody = haze(PALETTE.cloudLight, HAZE_MID);
            let midSheepLegs = haze(PALETTE.treeTrunkDark, HAZE_MID);
            midSheeps.forEach(ms => {
                ms.x += ms.speed;
                if (ms.x > ms.rightBound + 5) ms.x = ms.leftBound - 5;
                if (ms.x < ms.leftBound - 5) ms.x = ms.rightBound + 5;
                let py = Math.round(getHillY(ms.hill, ms.x));
                if (py >= HORIZON - 1) return;
                let px = Math.round(ms.x);
                let isEating = Math.sin(time * 0.002 + ms.offset) > 0.6;
                ctx.fillStyle = midSheepBody;
                ctx.fillRect(px, py - 1, 2, 1);
                ctx.fillRect(px, py - 2, 1, 1);
                ctx.fillStyle = midSheepLegs;
                ctx.fillRect(px, py, 1, 1);
                ctx.fillRect(px + 1, py, 1, 1);
                ctx.fillRect(ms.speed > 0 ? px + 2 : px - 1, py - 1 + (isEating ? 1 : 0), 1, 1);
            });

            // NEAR HILLS
            mountains.near.forEach(m => {
                fillHillWithVerticalFade(m, PALETTE.hillNear, HAZE_NEAR);
                drawHillPatches(m, PALETTE.hillNearLight, PALETTE.hillNearShadow, PALETTE.hillNearField, HAZE_NEAR);
                drawHedgeRow(m, PALETTE.hillNearDark, HAZE_NEAR);
                drawTreeLine(m, PALETTE.hillNearTree, 0.35, 5, HAZE_NEAR);
                drawStaticHomes(m, '#d4b898', '#6e2e2e', HAZE_NEAR, 2);
            });

            // HORIZON HAZE BAND
            let hazeHex = rgbToHex(PALETTE.horizonHaze.r, PALETTE.horizonHaze.g, PALETTE.horizonHaze.b);
            let hazeBandH = 8;
            for (let i = 0; i < hazeBandH; i++) {
                let t = 1.0 - (i / hazeBandH);
                t = t * t * 0.3;
                ctx.globalAlpha = t;
                ctx.fillStyle = hazeHex;
                ctx.fillRect(0, HORIZON - hazeBandH + i, canvas.width, 1);
            }
            ctx.globalAlpha = 1.0;

            // Sheep
            sheeps.forEach(s => {
                s.x+=s.speed; if (s.x>canvas.width+10) s.x=-10; if (s.x<-10) s.x=canvas.width+10;
                let isEating=Math.sin(time*0.002+s.offset)>0.6;
                let sx=Math.round(s.x), sy=Math.round(s.y);
                ctx.fillStyle=PALETTE.cloudLight; ctx.fillRect(sx,sy,3,2); ctx.fillRect(sx+1,sy-1,1,1);
                ctx.fillStyle=PALETTE.treeTrunkDark; ctx.fillRect(sx,sy+2,1,1); ctx.fillRect(sx+2,sy+2,1,1);
                ctx.fillRect(s.speed>0?sx+3:sx-1, sy+(isEating?1:0), 1, 1);
            });

            birds.forEach(b => {
                let bs = b.size || 1;
                b.x+=0.15*bs; b.y+=Math.sin(time*0.0015+b.offset)*0.1; if (b.x>canvas.width+20) b.x=-20;
                let wingFlap = Math.sin(time*0.008+b.offset)*bs;
                let bx=Math.round(b.x), by=Math.round(b.y);
                if (bs >= 1.5) {
                    // Detailed bird for nearby/larger ones
                    let bodyCol = '#2c3040';
                    let wingCol = '#3a4050';
                    let wingTip = '#1a2030';
                    let bellyCol = '#5a5a60';
                    let beakCol = '#d4a840';
                    // Body (elongated)
                    ctx.fillStyle = bodyCol;
                    ctx.fillRect(bx-Math.round(bs), by-Math.round(bs*0.5), Math.round(3*bs), Math.round(2*bs));
                    // Belly
                    ctx.fillStyle = bellyCol;
                    ctx.fillRect(bx-Math.round(bs*0.5), by, Math.round(2*bs), Math.round(bs));
                    // Head
                    ctx.fillStyle = bodyCol;
                    ctx.fillRect(bx+Math.round(2*bs), by-Math.round(bs), Math.round(2*bs), Math.round(2*bs));
                    // Eye
                    ctx.fillStyle = '#f0e8d0';
                    ctx.fillRect(bx+Math.round(3*bs), by-Math.round(bs*0.5), Math.max(1,Math.round(bs*0.4)), Math.max(1,Math.round(bs*0.4)));
                    // Beak
                    ctx.fillStyle = beakCol;
                    ctx.fillRect(bx+Math.round(4*bs), by-Math.round(bs*0.3), Math.max(1,Math.round(bs*0.8)), Math.max(1,Math.round(bs*0.3)));
                    // Tail feathers
                    ctx.fillStyle = wingTip;
                    ctx.fillRect(bx-Math.round(2*bs), by-Math.round(bs*0.3), Math.round(1.5*bs), Math.round(bs));
                    // Wings with feather detail
                    ctx.fillStyle = wingCol;
                    let lwY = by-Math.round((2+wingFlap)*bs);
                    let rwY = by-Math.round((2-wingFlap)*bs);
                    // Left wing
                    ctx.fillRect(bx-Math.round(bs), lwY, Math.round(2*bs), Math.round(2*bs));
                    ctx.fillRect(bx-Math.round(2*bs), lwY+Math.round(bs*0.3), Math.round(bs), Math.round(bs*1.2));
                    // Wing tip
                    ctx.fillStyle = wingTip;
                    ctx.fillRect(bx-Math.round(2.5*bs), lwY+Math.round(bs*0.5), Math.round(bs*0.8), Math.round(bs*0.8));
                    // Right wing
                    ctx.fillStyle = wingCol;
                    ctx.fillRect(bx+Math.round(bs), rwY, Math.round(2*bs), Math.round(2*bs));
                    ctx.fillRect(bx+Math.round(3*bs), rwY+Math.round(bs*0.3), Math.round(bs), Math.round(bs*1.2));
                    ctx.fillStyle = wingTip;
                    ctx.fillRect(bx+Math.round(3.5*bs), rwY+Math.round(bs*0.5), Math.round(bs*0.8), Math.round(bs*0.8));
                } else {
                    // Small distant bird — simple silhouette
                    ctx.fillStyle='#2c3e50';
                    ctx.fillRect(bx, by, Math.round(2*bs), Math.round(bs));
                    ctx.fillRect(bx-Math.round(2*bs), by-Math.round((2+wingFlap)*bs), Math.round(2*bs), Math.round(2*bs));
                    ctx.fillRect(bx+Math.round(2*bs), by-Math.round((2-wingFlap)*bs), Math.round(2*bs), Math.round(2*bs));
                }
            });
        }

        function drawGround() {
            let startY=Math.floor(HORIZON)+1;
            ctx.fillStyle=PALETTE.grassLight; ctx.fillRect(0,startY,canvas.width,canvas.height-startY);
            // Pre-blend stripe colors toward base for softer contrast
            let gl = PALETTE.grassLight;
            let blend = 0.4; // 40% blend toward base
            let softDark = lerpColor(PALETTE.grassDark, hexToRgb(gl), blend);
            let softDarker = lerpColor(PALETTE.grassDarker, hexToRgb(gl), blend);
            let softMid = lerpColor(PALETTE.grassMid, hexToRgb(gl), 0.25);
            let softHighlight = lerpColor(PALETTE.grassHighlight, hexToRgb(gl), 0.3);
            let softTip = lerpColor(PALETTE.grassTipHighlight, hexToRgb(gl), 0.35);
            let softDirtEdge = lerpColor(PALETTE.dirtEdge, hexToRgb(gl), 0.4);
            let softDirtMid = lerpColor(PALETTE.dirtMid, hexToRgb(gl), 0.4);
            for (let y=startY; y<canvas.height; y++) {
                let z=(FOV*CAMERA_Y)/(y-HORIZON); if (z>MAX_Z) continue;
                let scale=FOV/(FOV+z), actualZ=z+cameraZ, zIndex=Math.floor(actualZ/15);
                // Fade ground stripe contrast in mid-distance (z 200-800)
                let midFade = z < 200 ? 0.7 : z > 800 ? 0.3 : 0.7 - (z - 200) / 600 * 0.4;
                ctx.globalAlpha = midFade;
                ctx.fillStyle=softDark;
                let ns=3+(Math.abs(Math.sin(zIndex*0.77))*6);
                for(let i=0;i<ns;i++) { let hx=Math.sin(zIndex*0.11+i*1.5)*10000, wx=(Math.abs(hx)%6000)-3000;
                    ctx.fillRect(cx+wx*scale,y,(150+(Math.abs(Math.cos(zIndex+i))*250))*scale,1); }
                ctx.fillStyle=softDarker;
                let nd=2+(Math.abs(Math.cos(zIndex*1.3))*4);
                for(let i=0;i<nd;i++) { let hx=Math.cos(zIndex*0.23+i*2.1)*10000, wx=(Math.abs(hx)%6000)-3000;
                    ctx.fillRect(cx+wx*scale,y,(80+(Math.abs(Math.sin(zIndex-i))*150))*scale,1); }
                // Extra mid-tone grass stripes for color variety
                ctx.fillStyle=softMid;
                let nm=2+(Math.abs(Math.sin(zIndex*0.53))*4);
                for(let i=0;i<nm;i++) { let hx=Math.sin(zIndex*0.31+i*2.7)*10000, wx=(Math.abs(hx)%6000)-3000;
                    ctx.fillRect(cx+wx*scale,y,(80+(Math.abs(Math.cos(zIndex+i*0.7))*140))*scale,1); }
                // Soft highlight stripes
                ctx.fillStyle=softHighlight;
                let nh=2+(Math.abs(Math.cos(zIndex*0.91))*3);
                for(let i=0;i<nh;i++) { let hx=Math.cos(zIndex*0.17+i*3.3)*10000, wx=(Math.abs(hx)%6000)-3000;
                    ctx.fillRect(cx+wx*scale,y,(40+(Math.abs(Math.sin(zIndex+i*1.3))*80))*scale,1); }
                ctx.globalAlpha = 1;
                // Fine-detail pass: breaks up thick bands at close range
                let fineIdx=Math.floor(actualZ/3);
                let bandBreak = Math.max(0, 1 - z/500);
                if (bandBreak > 0 && fineIdx%2===0) {
                    ctx.globalAlpha = 0.5 * bandBreak;
                    ctx.fillStyle=softMid;
                    let fx=Math.sin(fineIdx*0.47)*8000, fwx=(Math.abs(fx)%4000)-2000;
                    ctx.fillRect(cx+fwx*scale,y,(60+Math.abs(Math.cos(fineIdx*0.8))*100)*scale,1);
                    ctx.fillStyle=softHighlight;
                    let fx2=Math.cos(fineIdx*0.71)*8000, fwx2=(Math.abs(fx2)%4000)-2000;
                    ctx.fillRect(cx+fwx2*scale,y,(30+Math.abs(Math.sin(fineIdx*1.1))*50)*scale,1);
                    ctx.globalAlpha = 1;
                }
                // Scattered small dirt/earth patches (subtler)
                if (hash(zIndex*2.3)>0.55) {
                    ctx.globalAlpha = 0.5;
                    ctx.fillStyle=softDirtEdge;
                    let dirtX=(hash(zIndex*4.1)-0.5)*1200;
                    ctx.fillRect(cx+dirtX*scale,y,Math.max(1,Math.round((20+hash(zIndex*6.7)*40)*scale)),1);
                    ctx.globalAlpha = 1;
                }
                if (hash(zIndex*3.7)>0.7) {
                    ctx.globalAlpha = 0.45;
                    ctx.fillStyle=softDirtMid;
                    let dirtX2=(hash(zIndex*5.3)-0.5)*800;
                    ctx.fillRect(cx+dirtX2*scale,y,Math.max(1,Math.round((10+hash(zIndex*8.1)*25)*scale)),1);
                    ctx.globalAlpha = 1;
                }
                // Pebble/stone dots (fewer, softer)
                let pebbleColors=[PALETTE.pebbleLight,PALETTE.pebbleMid,PALETTE.pebbleDark];
                for (let p=0; p<2; p++) {
                    if (hash(zIndex*7.3+p*13.1)>0.65) {
                        ctx.globalAlpha = 0.4;
                        ctx.fillStyle=pebbleColors[Math.floor(hash(zIndex*3.1+p*9.7)*3)];
                        let px=cx+(hash(zIndex*5.7+p*11.3)-0.5)*2000*scale;
                        ctx.fillRect(Math.round(px),y,Math.max(1,Math.round(2*scale)),1);
                        ctx.globalAlpha = 1;
                    }
                }
                // Tip-highlight dots (subtler)
                if (hash(zIndex*1.9)>0.7) {
                    ctx.globalAlpha = 0.4;
                    ctx.fillStyle=softTip;
                    let tipX=(hash(zIndex*9.1)-0.5)*1600;
                    ctx.fillRect(cx+tipX*scale,y,Math.max(1,Math.round(scale)),1);
                    ctx.globalAlpha = 1;
                }

                // River/lake on the right side — left bank meanders, extends to right edge
                let riverBankX = 650 + Math.sin(actualZ * 0.004) * 80 + Math.sin(actualZ * 0.0012) * 50;
                let riverLeft = cx + riverBankX * scale;
                if (riverLeft < canvas.width) {
                    let rl = Math.max(0, Math.round(riverLeft));
                    let rw = canvas.width - rl;
                    if (rw > 0) {
                        // Water base color — gets lighter/hazier with distance
                        let waterHaze = Math.min(0.6, z / MAX_Z);
                        let waterDeep = lerpColor('#3a7a9a', PALETTE.horizonHaze, waterHaze);
                        let waterMid = lerpColor('#4a8aaa', PALETTE.horizonHaze, waterHaze);
                        let waterLight = lerpColor('#6aaac4', PALETTE.horizonHaze, waterHaze);
                        let waterShimmer = lerpColor('#90c8e0', PALETTE.horizonHaze, waterHaze);
                        // Base water
                        ctx.fillStyle = waterDeep;
                        ctx.fillRect(rl, y, rw, 1);
                        // Mid tone strip (screen z for position, slow time for gentle shimmer)
                        let wt = time * 0.0004;
                        let midOff = Math.sin(z * 0.03 + wt) * rw * 0.15;
                        ctx.fillStyle = waterMid;
                        ctx.fillRect(rl + Math.round(rw * 0.15 + midOff), y, Math.round(rw * 0.4), 1);
                        // Gentle shimmer highlights (screen z + slow time)
                        let ripple1 = Math.sin(z * 0.05 + wt * 1.3) * 0.5 + 0.5;
                        let ripple2 = Math.sin(z * 0.08 + 2.0 + wt * 0.8) * 0.5 + 0.5;
                        let ripple3 = Math.sin(z * 0.035 + 4.0 + wt * 1.1) * 0.5 + 0.5;
                        if (ripple1 > 0.65) {
                            ctx.fillStyle = waterLight;
                            let rx = rl + Math.round(ripple1 * rw * 0.5 + rw * 0.05);
                            ctx.fillRect(rx, y, Math.max(1, Math.round(rw * 0.12)), 1);
                        }
                        if (ripple2 > 0.7) {
                            ctx.fillStyle = waterShimmer;
                            let rx2 = rl + Math.round(ripple2 * rw * 0.4 + rw * 0.3);
                            ctx.fillRect(rx2, y, Math.max(1, Math.round(rw * 0.08)), 1);
                        }
                        if (ripple3 > 0.72) {
                            ctx.fillStyle = waterLight;
                            let rx3 = rl + Math.round(ripple3 * rw * 0.6 + rw * 0.2);
                            ctx.fillRect(rx3, y, Math.max(1, Math.round(rw * 0.1)), 1);
                        }
                        // Left bank edge — dark grass/mud
                        let bankW = Math.max(1, Math.round(3 * scale));
                        ctx.fillStyle = PALETTE.grassDarker;
                        ctx.fillRect(rl - bankW, y, bankW, 1);
                        ctx.fillStyle = PALETTE.dirtEdge;
                        ctx.fillRect(rl, y, Math.max(1, Math.round(2 * scale)), 1);
                    }
                }
            }
        }

        function drawGrass(sx,sy,scale,variant) {
            let isTall=variant>=8, w=(isTall?5:3+(variant%3))*scale, h=(isTall?20+(variant%2)*10:8+(variant%4)*2)*scale;
            let col=PALETTE.grassShades[variant%PALETTE.grassShades.length], darkCol=PALETTE.grassShades[(variant+2)%PALETTE.grassShades.length];
            let midCol=PALETTE.grassShades[(variant+4)%PALETTE.grassShades.length];
            drawRect(sx-w/2,sy-h,w,h,darkCol); drawRect(sx-w/4,sy-h*0.8,w/2,h*0.8,col);
            // Mid-tone accent strip
            drawRect(sx-w/6,sy-h*0.5,w/3,h*0.3,midCol);
            if (isTall) {
                drawRect(sx-w,sy-h*0.9,2*scale,h*0.7,darkCol); drawRect(sx+w*0.5,sy-h*1.1,2*scale,h*0.8,col); drawRect(sx+w*0.5+2*scale,sy-h*1.1,3*scale,2*scale,col);
                // Bright tip highlights on tall blades
                drawRect(sx-w/4,sy-h-scale,Math.max(1,scale),Math.max(1,scale),PALETTE.grassTipHighlight);
                drawRect(sx+w*0.5+scale,sy-h*1.1-scale,Math.max(1,scale),Math.max(1,scale),PALETTE.grassTipHighlight);
            } else {
                drawRect(sx+w/4,sy-h*1.2,1.5*scale,h*0.6,col);
                // Bright tip highlight on short blade
                drawRect(sx,sy-h-scale,Math.max(1,scale),Math.max(1,scale),PALETTE.grassTipHighlight);
            }
        }

        function getTreeHazeFactor(relZ) { return Math.max(0, Math.min(1, relZ/MAX_Z))*0.4; }

        function getPineBlocks(sx,sy,scale,wind,trunkH,variant) {
            let blocks=[], tiers=4+(variant%2);
            for (let i=0; i<tiers; i++) {
                let tw=(70-i*15)*scale, th=28*scale, ty=sy-trunkH+(5-i*20)*scale, wo=wind*(0.2+i*0.15);
                blocks.push({x:sx-tw/2+wo,y:ty,w:tw,h:th});
                blocks.push({x:sx-tw/2+wo-2*scale,y:ty+th*0.3,w:2*scale,h:th*0.7});
                blocks.push({x:sx+tw/2+wo,y:ty+th*0.3,w:2*scale,h:th*0.7});
                blocks.push({x:sx-tw/2+wo-5*scale,y:ty+th*0.5,w:3*scale,h:th*0.4});
                blocks.push({x:sx+tw/2+wo+2*scale,y:ty+th*0.5,w:3*scale,h:th*0.4});
            }
            return blocks;
        }

        function getOakBlocks(sx,sy,scale,wind,trunkH) {
            let cy=sy-trunkH-20*scale, wo=wind*0.4;
            return [{x:0,y:0,w:90,h:70},{x:-25,y:-10,w:60,h:50},{x:25,y:-10,w:60,h:50},
                {x:0,y:-30,w:70,h:50},{x:-35,y:15,w:40,h:40},{x:35,y:15,w:40,h:40},
                {x:-40,y:-20,w:25,h:25},{x:40,y:-20,w:25,h:25},{x:-20,y:-45,w:30,h:25},
                {x:20,y:-45,w:30,h:25},{x:-45,y:5,w:20,h:20},{x:45,y:5,w:20,h:20}
            ].map(b=>({ x:sx+b.x*scale+wo-(b.w*scale)/2, y:cy+b.y*scale, w:b.w*scale, h:b.h*scale }));
        }

        function drawTree(sx,sy,scale,origX,origZ,variant,hScale,relZ) {
            scale*=1.8*hScale;
            let wind=Math.sin(time*0.001+origX*0.1+origZ*0.05)*6*scale;
            let trunkW=Math.max(3,16*scale), trunkH=(60+(Math.abs(Math.round(origX))%80))*scale;
            let isPine=(variant%2===0);
            let hazeFactor=getTreeHazeFactor(relZ), hazeRgb=PALETTE.hazeColor;
            let canopyBlocks=isPine ? getPineBlocks(sx,sy,scale,wind,trunkH,variant) : getOakBlocks(sx,sy,scale,wind,trunkH);

            let outlinePad=Math.max(1,Math.round(2*scale));
            let shadowOffX=Math.max(1,Math.round(3*scale));
            let shadowOffY=Math.max(1,Math.round(3*scale));
            let rimWidth=Math.max(1,Math.round(1.5*scale));

            ctx.fillStyle=PALETTE.treeShadowDrop;
            canopyBlocks.forEach(b=>{ ctx.fillRect(Math.round(b.x+shadowOffX),Math.round(b.y+shadowOffY),Math.round(b.w),Math.round(b.h)); });

            let outlineColor=hazeFactor>0?lerpColor(PALETTE.treeOutline,hazeRgb,hazeFactor*0.8):PALETTE.treeOutline;
            ctx.fillStyle=outlineColor;
            canopyBlocks.forEach(b=>{ ctx.fillRect(Math.round(b.x-outlinePad),Math.round(b.y-outlinePad),Math.round(b.w+outlinePad*2),Math.round(b.h+outlinePad*2)); });

            let trunkCol=hazeFactor>0?lerpColor(PALETTE.treeTrunk,hazeRgb,hazeFactor):PALETTE.treeTrunk;
            let trunkDarkCol=hazeFactor>0?lerpColor(PALETTE.treeTrunkDark,hazeRgb,hazeFactor):PALETTE.treeTrunkDark;
            drawRect(sx-trunkW/2,sy-trunkH,trunkW/2,trunkH,trunkDarkCol);
            drawRect(sx,sy-trunkH,trunkW/2,trunkH,trunkCol);
            drawRect(sx-trunkW*0.2,sy-trunkH*0.8,2*scale,trunkH*0.6,trunkDarkCol);

            if (isPine) {
                let tiers=4+(variant%2);
                for (let i=0; i<tiers; i++) {
                    let tw=(70-i*15)*scale, th=28*scale, ty=sy-trunkH+(5-i*20)*scale, wo=wind*(0.2+i*0.15);
                    let bc=lerpColor(PALETTE.pineLeavesBase[i%3],hazeRgb,hazeFactor);
                    let hc=lerpColor(PALETTE.pineLeavesHigh[i%3],hazeRgb,hazeFactor);
                    let sc=lerpColor(PALETTE.pineLeavesShadow[i%3],hazeRgb,hazeFactor);
                    drawRect(sx-tw/2+wo,ty+th*0.4,tw,th*0.6,sc);
                    drawRect(sx-tw/2+wo,ty,tw/2,th*0.8,bc);
                    drawRect(sx+wo,ty,tw/2,th*0.8,hc);
                    drawRect(sx-tw/2+wo-2*scale,ty+th*0.3,2*scale,th*0.7,bc);
                    drawRect(sx+tw/2+wo,ty+th*0.3,2*scale,th*0.7,hc);
                    drawRect(sx-tw/2+wo-5*scale,ty+th*0.5,3*scale,th*0.4,bc);
                    drawRect(sx+tw/2+wo+2*scale,ty+th*0.5,3*scale,th*0.4,hc);
                    drawRect(sx-tw/3+wo,ty+th,6*scale,4*scale,sc);
                    drawRect(sx+tw/4+wo,ty+th,6*scale,4*scale,sc);
                }
            } else {
                let cy=sy-trunkH-20*scale, wo=wind*0.4;
                [{x:0,y:0,w:90,h:70},{x:-25,y:-10,w:60,h:50},{x:25,y:-10,w:60,h:50},
                 {x:0,y:-30,w:70,h:50},{x:-35,y:15,w:40,h:40},{x:35,y:15,w:40,h:40},
                 {x:-40,y:-20,w:25,h:25},{x:40,y:-20,w:25,h:25},{x:-20,y:-45,w:30,h:25},
                 {x:20,y:-45,w:30,h:25},{x:-45,y:5,w:20,h:20},{x:45,y:5,w:20,h:20}
                ].forEach(b => {
                    let bw=b.w*scale, bh=b.h*scale, bx=sx+b.x*scale+wo, by=cy+b.y*scale;
                    let bc=lerpColor(PALETTE.oakLeavesBase[variant%3],hazeRgb,hazeFactor);
                    let hc=lerpColor(PALETTE.oakLeavesHigh[variant%3],hazeRgb,hazeFactor);
                    let sc=lerpColor(PALETTE.oakLeavesShadow[variant%3],hazeRgb,hazeFactor);
                    drawRect(bx-bw/2,by+bh*0.2,bw,bh*0.8,sc);
                    drawRect(bx-bw/2,by,bw/2,bh*0.7,bc);
                    drawRect(bx,by,bw/2,bh*0.7,hc);
                    drawRect(bx-bw/2-2*scale,by+bh*0.2,2*scale,bh*0.5,bc);
                    drawRect(bx+bw/2,by+bh*0.2,2*scale,bh*0.5,hc);
                });
            }

            let rimColor=lerpColor(PALETTE.rimLight,hazeRgb,hazeFactor*0.5);
            let rimBright=lerpColor(PALETTE.rimLightBright,hazeRgb,hazeFactor*0.5);
            let rimAlpha = isPine ? Math.max(0.05, 0.2-hazeFactor) : Math.max(0.05, 0.35-hazeFactor);
            ctx.globalAlpha=rimAlpha;
            canopyBlocks.forEach(b => {
                drawRect(b.x+b.w-rimWidth, b.y, rimWidth, b.h, rimColor);
            });
            ctx.globalAlpha=1.0;
        }

        function drawLeaf(sx,sy,scale,leaf) {
            let isPine = leaf.treeType === 0;
            let w = Math.max(1, (isPine ? 6 : 10) * scale);
            let h = Math.max(1, (isPine ? 14 : 10) * scale);
            let shape = leaf.shape || 0;
            if (shape === 0) {
                // Diamond: narrow top/bottom, wide middle
                let mid = Math.round(h / 2);
                for (let row = 0; row < Math.round(h); row++) {
                    let frac = row < mid ? row / mid : (Math.round(h) - row) / (Math.round(h) - mid);
                    let rw = Math.max(1, Math.round(w * frac));
                    ctx.fillStyle = leaf.color;
                    ctx.fillRect(Math.round(sx + (w - rw) / 2), Math.round(sy + row), rw, 1);
                }
            } else if (shape === 1) {
                // Pointed oval: wider in upper third, tapers to point
                for (let row = 0; row < Math.round(h); row++) {
                    let t = row / Math.round(h);
                    let frac = Math.sin(t * Math.PI * 0.8) * 1.1;
                    let rw = Math.max(1, Math.round(w * Math.min(1, frac)));
                    ctx.fillStyle = leaf.color;
                    ctx.fillRect(Math.round(sx + (w - rw) / 2), Math.round(sy + row), rw, 1);
                }
            } else {
                // Pine needle: tapered elongated shape (narrow at both ends, widest at 1/3)
                for (let row = 0; row < Math.round(h); row++) {
                    let t = row / Math.round(h);
                    let frac = t < 0.33 ? (t / 0.33) * 0.8 : 0.8 * (1 - (t - 0.33) / 0.67);
                    let rw = Math.max(1, Math.round(w * 0.5 * Math.max(0.15, frac)));
                    ctx.fillStyle = leaf.color;
                    ctx.fillRect(Math.round(sx + (w - rw) / 2), Math.round(sy + row), rw, 1);
                }
            }
        }

        function updateDogState() {
            let ds = dogState;
            ds.timer--;
            if (ds.timer <= 0) {
                let r = Math.random();
                if (ds.mode === 'walk') {
                    if (r < 0.25) {
                        // Run far ahead
                        ds.mode = 'runForward'; ds.targetX = 30+Math.random()*15; ds.targetY = -60 - Math.random()*30;
                        ds.speedMult = 3; ds.timer = 250 + Math.random()*150;
                    } else if (r < 0.65) {
                        // Run to the right side (never left)
                        ds.mode = 'runSide'; ds.facing = 1;
                        ds.targetX = 18 + (50+Math.random()*30); ds.targetY = -15-Math.random()*20;
                        ds.speedMult = 2.5; ds.timer = 200+Math.random()*120;
                    } else if (r < 0.80) {
                        // Sniff — stop where the dog currently is, person catches up
                        ds.mode = 'sniff'; ds.targetX = ds.offsetX; ds.targetY = ds.offsetY;
                        ds.speedMult = 0; ds.timer = 180+Math.random()*120;
                    } else {
                        ds.targetX = 25 + Math.random()*15; ds.targetY = -5;
                        ds.timer = 150 + Math.random()*250; // keep walking right of person
                    }
                } else if (ds.mode === 'sniff') {
                    // After sniffing, the person has caught up, so dog is near character
                    // Run off again or walk
                    let r2 = Math.random();
                    if (r2 < 0.4) {
                        ds.mode = 'runForward'; ds.targetX = 30+Math.random()*15; ds.targetY = -60 - Math.random()*30;
                        ds.speedMult = 3; ds.timer = 250+Math.random()*150;
                    } else if (r2 < 0.7) {
                        ds.mode = 'runSide'; ds.facing = 1;
                        ds.targetX = 18+(50+Math.random()*30); ds.targetY = -15-Math.random()*20;
                        ds.speedMult = 2.5; ds.timer = 200+Math.random()*120;
                    } else {
                        ds.mode = 'walk'; ds.targetX = 25+Math.random()*15; ds.targetY = -5;
                        ds.speedMult = 1; ds.timer = 150+Math.random()*200;
                    }
                } else {
                    // After runForward or runSide, sniff or return
                    if (Math.random() < 0.5) {
                        ds.mode = 'sniff'; ds.targetX = ds.offsetX; ds.targetY = ds.offsetY;
                        ds.speedMult = 0; ds.timer = 180+Math.random()*120;
                    } else {
                        ds.mode = 'returnBack'; ds.targetX = 28; ds.targetY = -5;
                        ds.speedMult = 2; ds.timer = 120+Math.random()*80;
                    }
                }
                if (ds.mode === 'returnBack' && Math.abs(ds.offsetX-28)<5 && Math.abs(ds.offsetY+5)<5) {
                    ds.mode = 'walk'; ds.speedMult = 1; ds.timer = 150+Math.random()*200;
                }
            }
            // Smoothly move toward target (sniffing = person catches up, so offset shrinks)
            let ease = ds.mode === 'sniff' ? 0.015 : 0.035;
            if (ds.mode === 'sniff') {
                // When sniffing, dog stays still but character walks forward, so offset drifts back
                ds.targetX = Math.max(20, ds.targetX - 0.08);
                ds.targetY = Math.min(0, ds.targetY + 0.05);
            }
            ds.offsetX += (ds.targetX - ds.offsetX) * ease;
            ds.offsetY += (ds.targetY - ds.offsetY) * ease;
            // Clamp: dog always stays to the right of person (min X=15)
            ds.offsetX = Math.max(15, Math.min(100, ds.offsetX));
            ds.offsetY = Math.max(-95, Math.min(5, ds.offsetY));
        }

        function drawDog(charX,charY,charScale,walkPhase) {
            updateDogState();
            let ds = dogState;
            let animSpeed = ds.speedMult;
            // Dog gets smaller when further ahead (offsetY more negative = further away)
            let distScale = 1 + Math.min(0, ds.offsetY) * 0.006; // e.g. offsetY=-90 → scale 0.46
            distScale = Math.max(0.4, Math.min(1, distScale));
            let dogScale = charScale * distScale;
            let bob=Math.abs(Math.sin(walkPhase*1.4*animSpeed))*2.5*Math.min(animSpeed,1.5)*distScale;
            let legSwing=Math.sin(walkPhase*1.4*animSpeed);
            let dogX=charX+ds.offsetX*dogScale, dogY=charY+ds.offsetY*dogScale;
            let isSniffing = ds.mode === 'sniff';
            let isSide = ds.mode === 'runSide';
            let d=(x,y,w,h,color)=>{ drawRect(dogX+x*dogScale,dogY+y*dogScale-bob,w*dogScale,h*dogScale,color); };

            // Shadow
            ctx.fillStyle='rgba(0,0,0,0.3)';
            ctx.fillRect(Math.round(dogX-5*dogScale),Math.round(dogY+12*dogScale),Math.round(12*dogScale),Math.round(3*dogScale));

            // Tail with wag (faster when running)
            let tailSpeed = ds.mode==='walk'||ds.mode==='sniff' ? 0.015 : 0.03;
            let tailWag=Math.sin(time*tailSpeed)*3;
            d(-2+tailWag,6,2,5,'#7A4E2D'); d(-2.5+tailWag*1.3,9,2,4,'#A0693E'); d(-3+tailWag*1.5,12,2,2,'#D4C4A8');

            // Back legs
            let lbl=legSwing>0?-legSwing*2.5:0, rbl=legSwing<0?legSwing*2.5:0;
            drawRect(dogX-4*dogScale,dogY+(5+lbl)*dogScale-bob,3*dogScale,(6-lbl)*dogScale,'#5A3520');
            drawRect(dogX+3*dogScale,dogY+(5+rbl)*dogScale-bob,3*dogScale,(6-rbl)*dogScale,'#6B3F22');
            d(-4,10.5,3,1.5,'#F0E8D8'); d(3,10.5,3,1.5,'#F0E8D8');

            // Body
            d(-5,-1,12,9,'#3D2517');
            d(-4,0,10,7,'#B8804A');
            d(-4,0,10,2,'#8B5E3C');
            d(-3,5,8,2,'#E8C888'); d(-2,6,6,1,'#F0D8A0');

            // Front legs — only visible when dog is facing sideways
            if (isSide || isSniffing) {
                let lfl=legSwing<0?legSwing*2.5:0, rfl=legSwing>0?-legSwing*2.5:0;
                drawRect(dogX-4*dogScale,dogY+(3+lfl)*dogScale-bob,3*dogScale,(4-lfl)*dogScale,'#5A3520');
                drawRect(dogX+4*dogScale,dogY+(3+rfl)*dogScale-bob,3*dogScale,(4-rfl)*dogScale,'#6B3F22');
                d(-4,6+lfl,3,1.5,'#F0E8D8'); d(4,6+rfl,3,1.5,'#F0E8D8');
            }

            // Head — orientation depends on state
            let headDipY = isSniffing ? 4 : 0; // sniffing = head down
            let headTurnX = isSide ? ds.facing * 5 : 0;
            let lookOffset = Math.sin(time*0.0018)*1.5 + headTurnX;

            if (isSide || isSniffing) {
                // Side/sniff view — show profile with eye and nose
                d(-4+lookOffset,-9+headDipY,10,7,'#3D2517');
                d(-3+lookOffset,-8+headDipY,8,5,'#B8804A');
                d(-2+lookOffset,-9+headDipY,6,2,'#C8945A');
                // Muzzle pointing to side
                let mDir = isSide ? ds.facing : (lookOffset > 0 ? 1 : -1);
                let mx = mDir > 0 ? 4 : -6;
                d(mx+lookOffset,-6+headDipY,3,2,'#E8C888');
                d(mx+1+lookOffset,-5+headDipY,2,1,'#F0E8D8');
                // Nose
                d(mx+1+lookOffset,-6+headDipY,1,1,'#0A0604');
                // Eye (profile — one visible)
                d(1+lookOffset,-7+headDipY,1,1,'#0A0604');
                // Ears
                let earBounce=Math.sin(walkPhase*1.4*animSpeed)*0.5;
                d(-6+lookOffset,-8+earBounce+headDipY,3,5,'#5A3520'); d(-5+lookOffset,-7+earBounce+headDipY,1,3,'#7A4E2D');
                d(5+lookOffset,-8+earBounce+headDipY,3,5,'#5A3520'); d(6+lookOffset,-7+earBounce+headDipY,1,3,'#7A4E2D');
            } else {
                // Back view — no face
                d(-4+lookOffset,-9+headDipY,10,7,'#3D2517');
                d(-3+lookOffset,-8+headDipY,8,5,'#B8804A');
                d(-2+lookOffset,-9+headDipY,6,2,'#A0693E');
                d(-2+lookOffset,-8+headDipY,6,1,'#8B5E3C');
                let earBounce=Math.sin(walkPhase*1.4*animSpeed)*0.5;
                d(-6+lookOffset,-8+earBounce+headDipY,3,5,'#5A3520'); d(-5+lookOffset,-7+earBounce+headDipY,1,3,'#7A4E2D');
                d(5+lookOffset,-8+earBounce+headDipY,3,5,'#5A3520'); d(6+lookOffset,-7+earBounce+headDipY,1,3,'#7A4E2D');
            }
            // Collar
            d(-4+lookOffset,-3+headDipY,10,2,'#CC2222');
            d(-3+lookOffset,-3+headDipY,8,1,'#FF4444');
            d(0+lookOffset,-2+headDipY,2,2,'#FFD700');
        }

        // Screen-space foreground detail (fills the bottom band the 3D projection can't reach)
        function drawForegroundDetail() {
            let bandTop = Math.round(HORIZON + CAMERA_Y * 0.7);
            let bandH = canvas.height - bandTop;
            if (bandH < 10) return;
            let numItems = 6000;
            for (let i = 0; i < numItems; i++) {
                // Each item has a fixed "lane" (x behavior) and scrolls vertically
                let seed = i * 37.0 + 0.5;
                let laneX = hash(seed); // 0-1 across screen width
                let basePhase = hash(seed + 1.3);
                // Scroll with perspective: slow at top (far), fast at bottom (close)
                let phase = (basePhase + cameraZ * 0.006) % 1.0;
                let phaseSq = phase * phase; // quadratic = slower at top, accelerates toward bottom
                let y = bandTop + phaseSq * bandH;
                // Perspective-correct x: match ground projection so items track with the ground
                let itemZ = (FOV * CAMERA_Y) / Math.max(1, y - HORIZON);
                let itemScale = FOV / (FOV + itemZ);
                let worldX = (laneX - 0.5) * 2500;
                let x = cx + worldX * itemScale;
                // Size: tiny at top, full size at bottom
                let sz = 0.1 + phaseSq * 1.1;
                // Fade in near the top, cap max opacity for subtlety
                ctx.globalAlpha = Math.min(0.6, phase * 1.2);
                let typeVal = hash(seed + 31.1);
                if (typeVal < 0.93) {
                    // Grass tuft — blended toward ground color for subtlety
                    let blendAmt = 0.35;
                    let shade = lerpColor(PALETTE.grassShades[i % PALETTE.grassShades.length], PALETTE.hazeColor, blendAmt);
                    let darkShade = lerpColor(PALETTE.grassShades[(i+3) % PALETTE.grassShades.length], PALETTE.hazeColor, blendAmt);
                    let w = 1;
                    let h = Math.max(1, Math.round((3 + hash(seed+11.3)*5) * sz));
                    ctx.fillStyle = darkShade;
                    ctx.fillRect(Math.round(x), Math.round(y-h), w, h);
                    ctx.fillStyle = shade;
                    ctx.fillRect(Math.round(x), Math.round(y-h), w, Math.max(.5,Math.round(h*0.6)));
                    // Tip highlight on larger tufts (subtle)
                    if (h > 4) {
                        ctx.fillStyle = lerpColor(PALETTE.grassTipHighlight, PALETTE.hazeColor, 0.3);
                        ctx.fillRect(Math.round(x), Math.round(y-h-1), 1, 1);
                    }
                } else if (typeVal < 0.95) {
                    // Flower — check if we're in a blue clump zone
                    let clumpKey = Math.floor((laneX * 8 + basePhase * 5) * 3.7);
                    let inBlueZone = (Math.sin(clumpKey * 2.31) > 0.55);
                    let stemH = Math.max(1, Math.round((4 + hash(seed+13.7)*5) * sz));
                    ctx.fillStyle = PALETTE.flowerStemGreen;
                    ctx.fillRect(Math.round(x), Math.round(y-stemH), 1, stemH);
                    let headSz = Math.max(1, Math.round(2 * sz));
                    if (inBlueZone) {
                        let blueCols = ['#4878c8', '#5888d8', '#3868b8', '#6898e0', '#5078c0'];
                        ctx.fillStyle = blueCols[i % blueCols.length];
                    } else {
                        ctx.fillStyle = PALETTE.flowerColors[i % PALETTE.flowerColors.length];
                    }
                    ctx.fillRect(Math.round(x - headSz/2), Math.round(y-stemH-headSz), headSz, headSz);
                    // Blue flowers get a tiny white center
                    if (inBlueZone && headSz >= 2) {
                        ctx.fillStyle = '#e8e8f0';
                        ctx.fillRect(Math.round(x), Math.round(y-stemH-headSz+1), Math.max(1, headSz-1), Math.max(1, headSz-1));
                    }
                } else if (typeVal < 0.955 && phase > 0.4) {
                    // Heart-shaped leaf plant — green with subtle color accent (fewer)
                    let leafGreens = ['#4a7a30', '#3a6828', '#5a8a38', '#487030', '#3e6e2a', '#528234'];
                    let accentCols = ['#c8e060', '#d4e870', '#b8d450', '#a8c840'];
                    let col = leafGreens[i % leafGreens.length];
                    let darkCol = leafGreens[(i+2) % leafGreens.length];
                    let accent = accentCols[i % accentCols.length];
                    let stemH = Math.max(2, Math.round((3 + hash(seed+15.3)*3) * sz));
                    let fx = Math.round(x), fy = Math.round(y);
                    // Short stem
                    ctx.fillStyle = PALETTE.flowerStemGreen;
                    ctx.fillRect(fx, fy - stemH, 1, stemH);
                    // Tiny leaf on stem
                    ctx.fillRect(fx - 1, fy - Math.round(stemH * 0.5), 2, 1);
                    // Heart shape: green leaf
                    let hs = Math.max(2, Math.round(3.5 * sz));
                    let topY = fy - stemH - hs * 2;
                    ctx.fillStyle = col;
                    // Left bump
                    ctx.fillRect(fx - hs, topY, hs, hs + 1);
                    // Right bump
                    ctx.fillRect(fx + 1, topY, hs, hs + 1);
                    // Fill between bumps
                    ctx.fillRect(fx - hs + 1, topY + 1, hs * 2 - 1, hs);
                    // Taper to point
                    for (let r = 0; r < hs; r++) {
                        let rw = Math.max(1, hs * 2 - 1 - r * 2);
                        ctx.fillRect(fx - Math.floor(rw / 2), topY + hs + 1 + r, rw, 1);
                    }
                    // Darker shading on lower half
                    ctx.fillStyle = darkCol;
                    ctx.fillRect(fx - Math.floor(hs / 2), topY + hs, hs, Math.max(1, Math.round(hs * 0.4)));
                    // Light color accent — small bright spot at center
                    ctx.fillStyle = accent;
                    ctx.fillRect(fx, topY + Math.round(hs * 0.4), Math.max(1, Math.round(sz)), Math.max(1, Math.round(sz)));
                } else if (typeVal < 0.98) {
                    // Small rock
                    let pColors = [PALETTE.pebbleLight, PALETTE.pebbleMid, PALETTE.pebbleDark];
                    let w = Math.max(1, Math.round((3 + hash(seed+19.3)*3) * sz));
                    let h = Math.max(1, Math.round((2 + hash(seed+21.7)*2) * sz));
                    ctx.fillStyle = pColors[i % 3];
                    ctx.fillRect(Math.round(x - w/2), Math.round(y-h), w, h);
                    ctx.fillStyle = pColors[(i+1) % 3];
                    ctx.fillRect(Math.round(x - w/2), Math.round(y-Math.ceil(h/2)), w, Math.max(1,Math.ceil(h/2)));
                } else {
                    // Dirt speck
                    ctx.fillStyle = hash(seed+41.1) > 0.5 ? PALETTE.dirtMid : PALETTE.dirtEdge;
                    let w = Math.max(1, Math.round((2 + hash(seed+43.3)*3) * sz));
                    ctx.fillRect(Math.round(x - w/2), Math.round(y-1), w, 1);
                }
            }
            ctx.globalAlpha = 1;
        }

        function drawCharacter() {
            let charX=cx, charY=canvas.height-20, charScale=1.2;
            let walkPhase=time*0.0056925, bob=Math.abs(Math.sin(walkPhase))*4, legSwing=Math.sin(walkPhase);
            let p=(x,y,w,h,color)=>{ drawRect(charX+x*charScale,charY+y*charScale-bob,w*charScale,h*charScale,color); };

            ctx.fillStyle='rgba(0,0,0,0.3)';
            ctx.fillRect(Math.round(charX-12*charScale),Math.round(charY+12*charScale),Math.round(24*charScale),Math.round(4*charScale));

            // Legs
            let llY=legSwing>0?-legSwing*5:0;
            drawRect(charX-6*charScale,charY+5*charScale-bob-llY,5*charScale,(10+llY)*charScale,'#1E3D59');
            let rlY=legSwing<0?legSwing*5:0;
            drawRect(charX+1*charScale,charY+5*charScale-bob-rlY,5*charScale,(10+rlY)*charScale,'#1E3D59');

            // Backpack (smaller)
            p(-7,-10,14,14,'#6B4226'); p(-6,-9,12,12,'#8B5A3C'); p(-5,-8,10,10,'#7A4C30');
            p(-1,-7,2,9,'#5A3520'); p(-7,-12,14,2,'#5A3520'); p(-6,-11,12,1,'#6B4226');
            p(-7,4,14,2,'#5A3520'); p(-7,-2,14,1,'#5A3520');
            p(-4,-1,8,4,'#7A4C30'); p(-3,0,6,2,'#8B5A3C'); p(-3,-1,6,1,'#5A3520');
            // Backpack straps
            p(-9,-2,3,7,'#6B4226'); p(6,-2,3,7,'#6B4226');
            // Water bottle on side
            p(6,-4,3,5,'#4A7A8C'); p(6,-5,3,2,'#5A8A9C');
            // Shirt visible above/below backpack
            p(-8,-16,16,4,'#3D6B4F'); p(-7,-15,14,2,'#4D7B5F'); p(-8,-16,16,1,'#2D5B3F');
            p(-5,-16,2,4,'#5A3520'); p(3,-16,2,4,'#5A3520');
            // Backpack side straps
            p(-7,-10,2,12,'#5A3520'); p(5,-10,2,12,'#5A3520');
            p(-6,-9,1,10,'#6B4226'); p(6,-9,1,10,'#6B4226');

            // Head
            p(-5,-24,10,10,'#f5cba7');
            // Hair
            p(-6,-26,12,8,'#2c1e16');
            p(-5,-25,10,6,'#3a2920'); p(-4,-24,8,4,'#2c1e16');
            // Ears
            p(-7,-22,2,3,'#f5cba7'); p(5,-22,2,3,'#f5cba7');

            // Hat (hiking/bucket hat)
            p(-8,-28,16,3,'#5a7a5a'); // brim
            p(-6,-31,12,4,'#4a6a4a'); // crown
            p(-5,-30,10,2,'#5a7a5a'); // crown highlight
            p(-9,-28,1,2,'#4a6a4a'); // brim shadow left
            p(7,-28,1,2,'#4a6a4a');  // brim shadow right
            p(-4,-31,8,1,'#3a5a3a');  // hat band

            // Arms
            let laY=legSwing*4;
            drawRect(charX-12*charScale,charY-8*charScale-bob+laY,3*charScale,10*charScale,'#d35400');
            let raY=-legSwing*4;
            drawRect(charX+9*charScale,charY-8*charScale-bob+raY,3*charScale,10*charScale,'#d35400');

            drawDog(charX,charY,charScale,walkPhase);
        }

        function loop(timestamp) {
            time+=3; cameraZ+=SPEED;

            // Update footsteps audio
            updateFootsteps();

            entities.forEach(e => {
                if (e.type==='leaf') { e.y+=e.speedY; e.x+=Math.sin(time*0.001+e.z)*1.2; }
                let relZ=e.z-cameraZ;
                if (relZ<1||(e.type==='leaf'&&e.y>CAMERA_Y)) {
                    if (e.type==='tree') { e.z+=MAX_Z; e.x=getRandomTreeX(); e.hScale=0.5+Math.random()*1.2; }
                    else if (e.type==='grass') { e.z+=MAX_Z; e.x=(Math.random()-0.5)*2000; e.variant=getGrassVariant(e.x,e.z); }
                    else if (e.type==='leaf') { resetLeaf(e); relZ=e.z-cameraZ; }
                    else if (e.type==='groundLeaf') {
                        e.z+=MAX_Z;
                        e.x=Math.min(550, (Math.random()-0.5)*2000);
                        e.color=PALETTE.groundLeafColors[Math.floor(Math.random()*PALETTE.groundLeafColors.length)];
                    }
                    else if (e.type==='home') {
                        e.z+=MAX_Z;
                        e.x=getRandomHomeX();
                    }
                    else if (e.type==='boat') {
                        e.z+=MAX_Z;
                        e.x=800+Math.random()*500;
                    }
                    else if (e.type==='person') {
                        e.z+=MAX_Z;
                        e.x=getRandomHomeX();
                    }
                    else if (e.type==='sheep') {
                        e.z+=MAX_Z;
                        e.x=getRandomTreeX() + (Math.random()-0.5)*80;
                        e.facing=Math.random()>0.5?1:-1;
                    }
                    else if (e.type==='cow') {
                        e.z+=MAX_Z;
                        e.x=getRandomHomeX();
                        e.facing=Math.random()>0.5?1:-1;
                    }
                    else if (e.type==='shepherd') {
                        e.z+=MAX_Z;
                        e.x=getRandomTreeX() + (Math.random()-0.5)*60;
                    }
                    else if (e.type==='bench') {
                        e.z+=MAX_Z;
                        e.x=480+Math.random()*100;
                    }
                    else if (e.type==='fisher') {
                        e.z+=MAX_Z;
                        e.x=482+Math.random()*100;
                    }
                }
                e.relZ=relZ;
            });
            entities.sort((a,b)=>b.relZ-a.relZ);
            ctx.clearRect(0,0,canvas.width,canvas.height);
            drawBackground(); drawGround();
            drawForegroundDetail();
            entities.forEach(e => {
                if (e.relZ>MAX_Z) return;
                let scale=FOV/(FOV+e.relZ), sx=cx+e.x*scale, sy=HORIZON+(e.y!==undefined?e.y:CAMERA_Y)*scale;
                if (e.type==='tree') drawTree(sx,sy,scale,e.x,e.z,e.variant,e.hScale,e.relZ);
                if (e.type==='leaf') drawLeaf(sx,sy,scale,e);
                // 3D grass tufts removed — foreground detail handles close grass
                if (e.type==='groundLeaf' && e.relZ < 1000) drawGroundLeaf(sx,sy,scale,e);
                if (e.type==='home') drawHome(sx,sy,scale,e,e.relZ);
                if (e.type==='boat') drawSailboat(sx,sy,scale,e,e.relZ);
                if (e.type==='person') drawPerson(sx,sy,scale,e,e.relZ);
                if (e.type==='sheep') drawGroundSheep(sx,sy,scale,e,e.relZ);
                if (e.type==='cow') drawCow(sx,sy,scale,e,e.relZ);
                if (e.type==='shepherd') drawShepherd(sx,sy,scale,e,e.relZ);
                if (e.type==='bench') drawBench(sx,sy,scale,e,e.relZ);
                if (e.type==='fisher') drawFisher(sx,sy,scale,e,e.relZ);
            });
            drawCharacter();
            requestAnimationFrame(loop);
        }

        init();
    </script>
</body>
</html>
