<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Pixel Art Hiking Loop</title>
    <style>
        body, html {
            margin: 0;
            padding: 0;
            width: 100%;
            height: 100%;
            background-color: #000;
            overflow: hidden;
            font-family: sans-serif;
        }
        canvas {
            display: block;
            width: 100vw;
            height: 100vh;
            image-rendering: -moz-crisp-edges;
            image-rendering: -webkit-optimize-contrast;
            image-rendering: crisp-edges;
            image-rendering: pixelated;
        }
        #audio-controls {
            position: absolute;
            top: 10px;
            right: 10px;
            z-index: 10;
        }
        #audio-toggle {
            background: rgba(0,0,0,0.5);
            color: #fff;
            border: 1px solid rgba(255,255,255,0.3);
            padding: 8px 12px;
            cursor: pointer;
            font-size: 16px;
            border-radius: 4px;
            letter-spacing: 1px;
        }
        #audio-toggle:hover {
            background: rgba(0,0,0,0.7);
        }
        #audio-panel {
            display: none;
            background: rgba(0,0,0,0.6);
            backdrop-filter: blur(4px);
            padding: 12px;
            margin-top: 4px;
            border-radius: 4px;
            min-width: 150px;
            border: 1px solid rgba(255,255,255,0.15);
        }
        #audio-panel.open {
            display: block;
        }
        .audio-slider {
            margin: 8px 0;
        }
        .audio-slider label {
            color: rgba(255,255,255,0.8);
            font-size: 11px;
            display: block;
            margin-bottom: 3px;
            letter-spacing: 0.5px;
        }
        .audio-slider input[type="range"] {
            width: 100%;
            -webkit-appearance: none;
            appearance: none;
            height: 4px;
            background: rgba(255,255,255,0.2);
            border-radius: 2px;
            outline: none;
        }
        .audio-slider input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 12px;
            height: 12px;
            background: #fff;
            border-radius: 50%;
            cursor: pointer;
        }
    </style>
</head>
<body>
    <div id="audio-controls">
        <button id="audio-toggle">&#9835; Sound</button>
        <div id="audio-panel">
            <div class="audio-slider">
                <label>Music</label>
                <input type="range" min="0" max="100" value="50" data-channel="music">
            </div>
            <div class="audio-slider">
                <label>Wind</label>
                <input type="range" min="0" max="100" value="20" data-channel="wind">
            </div>
            <div class="audio-slider">
                <label>Birds</label>
                <input type="range" min="0" max="100" value="30" data-channel="birds">
            </div>
            <div class="audio-slider">
                <label>Steps</label>
                <input type="range" min="0" max="100" value="40" data-channel="footsteps">
            </div>
            <div class="audio-slider">
                <label>Sheep</label>
                <input type="range" min="0" max="100" value="8" data-channel="sheep">
            </div>
        </div>
    </div>
    <canvas id="game"></canvas>

    <script>
        const canvas = document.getElementById('game');
        const ctx = canvas.getContext('2d');

        const PIXEL_SCALE = 4;
        let cx = 0;
        let HORIZON = 0;

        let time = 0;
        let cameraZ = 0;
        const SPEED = 0.25;
        const FOV = 200;
        const CAMERA_Y = 60;
        const MAX_Z = 2500;

        let entities = [];
        let clouds = [];
        let mountains = { far: [], mid: [], near: [] };
        let birds = [];
        let sheeps = [];

        const PALETTE = {
            skyBands: ['#a9d3e9', '#cbe1d6', '#f2e8b9', '#efc68b', '#e0985c'],
            sun: '#ffc15e',
            cloudLight: '#fdf6e2',
            cloudBase: '#e3d2b8',
            cloudShadow: '#c4a787',

            hillFar: '#7a9a6e', hillFarLight: '#8dab7d', hillFarShadow: '#6a8860', hillFarTree: '#5c7a52',
            hillMid: '#6d8e4a', hillMidLight: '#7ea058', hillMidShadow: '#5a7a3c', hillMidTree: '#4a6830', hillMidField: '#8ba55c',
            hillNear: '#5e7e38', hillNearLight: '#72943e', hillNearShadow: '#4c6a2c', hillNearTree: '#3a5822', hillNearField: '#7d9c48', hillNearDark: '#3e5520',

            grassLight: '#94a161', grassDark: '#78854a', grassDarker: '#5c6934',
            grassShades: ['#6c7a38', '#5c6934', '#94a161', '#78854a', '#4b5726'],
            treeTrunk: '#443125', treeTrunkDark: '#241810',
            pineLeavesBase: ['#2b4a2e', '#325736', '#3b663f'],
            pineLeavesHigh: ['#3b663f', '#46784a', '#528c57'],
            pineLeavesShadow: ['#162618', '#1c301e', '#213823'],
            oakLeavesBase: ['#59662f', '#667536', '#75873e'],
            oakLeavesHigh: ['#75873e', '#869947', '#99ad52'],
            oakLeavesShadow: ['#333b1b', '#3d4720', '#485426'],
            oakLeafColors: ['#99ad52', '#869947', '#b5a142', '#d48d3d'],

            treeOutline: '#1e3318',
            treeShadowDrop: 'rgba(20, 35, 15, 0.3)',
            rimLight: '#c8d878',
            rimLightBright: '#dae89a',
            hazeColor: { r: 138, g: 171, b: 110 },

            horizonHaze: { r: 215, g: 205, b: 170 },

            groundLeafColors: ['#8b6e3e', '#7a5c2e', '#6b4e28', '#9a7a42', '#a08848', '#b5a142', '#99ad52', '#869947', '#d48d3d', '#c47830'],
        };

        const HAZE_FAR = 0.45;
        const HAZE_MID = 0.22;
        const HAZE_NEAR = 0.08;

        function hexToRgb(hex) {
            return { r:parseInt(hex.slice(1,3),16), g:parseInt(hex.slice(3,5),16), b:parseInt(hex.slice(5,7),16) };
        }
        function rgbToHex(r,g,b) {
            return '#'+((1<<24)+(Math.round(Math.min(255,Math.max(0,r)))<<16)+(Math.round(Math.min(255,Math.max(0,g)))<<8)+Math.round(Math.min(255,Math.max(0,b)))).toString(16).slice(1);
        }
        function lerpColor(hex, hazeRgb, t) {
            let c = hexToRgb(hex);
            return rgbToHex(c.r+(hazeRgb.r-c.r)*t, c.g+(hazeRgb.g-c.g)*t, c.b+(hazeRgb.b-c.b)*t);
        }
        function haze(hex, amount) {
            return lerpColor(hex, PALETTE.horizonHaze, amount);
        }

        function resize() {
            canvas.width = Math.ceil(window.innerWidth/PIXEL_SCALE);
            canvas.height = Math.ceil(window.innerHeight/PIXEL_SCALE);
            cx = canvas.width/2;
            HORIZON = canvas.height*0.45;
            ctx.imageSmoothingEnabled = false;
            generateMountains();
        }

        function hash(n) { let x=Math.sin(n)*43758.5453; return x-Math.floor(x); }

        function generateMountains() {
            let cw = canvas.width;
            mountains.far = [
                { x:cw*0.15, w:cw*1.0, h:65+Math.random()*20, seed:Math.random()*999 },
                { x:cw*0.6, w:cw*1.3, h:80+Math.random()*20, seed:Math.random()*999 },
                { x:cw*1.05, w:cw*0.9, h:58+Math.random()*20, seed:Math.random()*999 },
            ];
            mountains.mid = [
                { x:cw*0.1, w:cw*1.1, h:50+Math.random()*15, seed:Math.random()*999 },
                { x:cw*0.55, w:cw*1.4, h:55+Math.random()*15, seed:Math.random()*999 },
                { x:cw*1.0, w:cw*1.0, h:45+Math.random()*15, seed:Math.random()*999 },
            ];
            mountains.near = [
                { x:cw*0.25, w:cw*1.5, h:35+Math.random()*12, seed:Math.random()*999 },
                { x:cw*0.85, w:cw*1.4, h:40+Math.random()*12, seed:Math.random()*999 },
            ];
            sheeps = [];
            for (let i=0; i<14; i++) {
                sheeps.push({ x:Math.random()*cw, y:HORIZON-8-Math.random()*20,
                    speed:(Math.random()>0.5?1:-1)*(0.00144+Math.random()*0.00288), offset:Math.random()*100 });
            }
        }

        function getHillY(m, px) {
            let t=(px-(m.x-m.w/2))/m.w;
            if (t<0||t>1) return HORIZON;
            return HORIZON - Math.sin(t*Math.PI)*m.h - Math.sin(t*Math.PI*4.5+m.seed)*m.h*0.08
                - Math.sin(t*Math.PI*7.2+m.seed*1.7)*m.h*0.04 - Math.sin(t*Math.PI*11.0+m.seed*2.3)*m.h*0.025;
        }

        function fillHillWithVerticalFade(m, baseColor, hazeAmount) {
            let left=Math.max(0,Math.floor(m.x-m.w/2)), right=Math.min(canvas.width,Math.ceil(m.x+m.w/2));
            let hazedBase = haze(baseColor, hazeAmount);
            ctx.fillStyle = hazedBase;
            ctx.beginPath(); ctx.moveTo(left, HORIZON);
            for (let px=left; px<=right; px++) ctx.lineTo(px, getHillY(m, px));
            ctx.lineTo(right, HORIZON); ctx.closePath(); ctx.fill();

            let minY = HORIZON;
            for (let px=left; px<=right; px+=4) { let y=getHillY(m,px); if(y<minY) minY=y; }
            let hillHeight = HORIZON - minY;
            if (hillHeight < 2) return;

            let extraFade = hazeAmount * 0.4;
            let hazedBottom = haze(baseColor, Math.min(0.85, hazeAmount + extraFade));
            let bottomRgb = hexToRgb(hazedBottom);
            let baseRgb = hexToRgb(hazedBase);

            let fadeStart = minY + hillHeight * 0.4;
            for (let y = Math.floor(fadeStart); y < HORIZON; y++) {
                let fadeT = (y - fadeStart) / (HORIZON - fadeStart);
                fadeT = fadeT * fadeT;
                let rowColor = rgbToHex(
                    baseRgb.r + (bottomRgb.r - baseRgb.r) * fadeT,
                    baseRgb.g + (bottomRgb.g - baseRgb.g) * fadeT,
                    baseRgb.b + (bottomRgb.b - baseRgb.b) * fadeT
                );
                ctx.fillStyle = rowColor;
                for (let px = left; px < right; px += 3) {
                    if (getHillY(m, px) <= y) {
                        ctx.fillRect(px, y, 3, 1);
                    }
                }
            }
        }

        function drawHillPatches(m, lightColor, shadowColor, fieldColor, hazeAmount) {
            let left=Math.max(0,Math.floor(m.x-m.w/2)), right=Math.min(canvas.width,Math.ceil(m.x+m.w/2));
            let hLight = haze(lightColor, hazeAmount);
            let hShadow = haze(shadowColor, hazeAmount);
            let hField = haze(fieldColor, hazeAmount);

            for (let px=left+2; px<right-2; px++) {
                let slope = getHillY(m,px+2)-getHillY(m,px);
                if (slope>0.3) { ctx.fillStyle=hShadow; ctx.fillRect(px, Math.round(getHillY(m,px)), 1, Math.round(HORIZON-getHillY(m,px))); }
                else if (slope<-0.3) { ctx.fillStyle=hLight; ctx.fillRect(px, Math.round(getHillY(m,px)), 1, Math.round(HORIZON-getHillY(m,px))); }
            }
            let np=3+Math.floor(hash(m.seed)*4);
            for (let i=0; i<np; i++) {
                let t=0.15+hash(m.seed+i*17)*0.7, px=m.x-m.w/2+t*m.w, pw=8+hash(m.seed+i*31)*25;
                let py=getHillY(m,px), ph=(HORIZON-py)*(0.2+hash(m.seed+i*7)*0.4);
                if (px>0&&px+pw<canvas.width) { ctx.fillStyle=hField; ctx.fillRect(Math.round(px),Math.round(py+(HORIZON-py)*0.2),Math.round(pw),Math.round(ph)); }
            }
        }

        function drawTreeLine(m, treeColor, density, maxTreeH, hazeAmount) {
            let left=Math.max(0,Math.floor(m.x-m.w/2)), right=Math.min(canvas.width,Math.ceil(m.x+m.w/2));
            ctx.fillStyle = haze(treeColor, hazeAmount);
            for (let px=left; px<right; px+=2) {
                let y=getHillY(m,px); if (y>=HORIZON-2) continue;
                if (hash(px*0.37+m.seed*1.1)>density) continue;
                let treeH=2+hash(px*0.53+m.seed)*maxTreeH, treeW=1+Math.floor(hash(px*0.71+m.seed)*2);
                let ty=Math.round(y);
                ctx.fillRect(px, ty-treeH, treeW, treeH);
                if (treeH>3) ctx.fillRect(px-1, ty-treeH, treeW+1, Math.round(treeH*0.4));
            }
        }

        function drawHedgeRow(m, color, hazeAmount) {
            let left=Math.max(0,Math.floor(m.x-m.w/2)), right=Math.min(canvas.width,Math.ceil(m.x+m.w/2));
            let band=0.3+hash(m.seed*3.7)*0.3;
            ctx.fillStyle = haze(color, hazeAmount);
            for (let px=left; px<right; px++) {
                let topY=getHillY(m,px), bandY=topY+(HORIZON-topY)*band;
                if (bandY<HORIZON-1) { ctx.fillRect(px, Math.round(bandY), 1, 1);
                    if (hash(px*0.19+m.seed)>0.6) ctx.fillRect(px, Math.round(bandY)-1, 1, 1); }
            }
        }

        // Random tree placement across full width, excluding center path
        function getRandomTreeX() {
            let x;
            do {
                x = (Math.random() - 0.5) * 3000; // range -1500 to 1500
            } while (Math.abs(x) < 180); // exclude center path zone
            return x;
        }

        function getGrassVariant(x,z) {
            let noise=Math.sin(x*0.002)+Math.cos(z*0.002)+Math.sin((x+z)*0.003);
            if (noise>1.2) return 8+Math.floor(Math.random()*2);
            return Math.floor(Math.random()*8);
        }

        function resetLeaf(leaf) {
            let trees=entities.filter(e=>e.type==='tree');
            if (!trees.length) return;
            let tree=trees[Math.floor(Math.random()*trees.length)];
            let isPine=(tree.variant%2===0);
            leaf.x=tree.x+(Math.random()-0.5)*300; // wider X spread (+/-150)
            leaf.z=tree.z-80+Math.random()*120; // range -80 to +40 from tree (negative = in front)
            leaf.y=-10-Math.random()*130; // higher starting Y (-10 to -140)
            leaf.speedY=0.03+Math.random()*0.06;
            leaf.treeType=isPine?0:1;
            let colors=isPine?PALETTE.pineLeavesHigh:PALETTE.oakLeafColors;
            leaf.color=colors[Math.floor(Math.random()*colors.length)];
        }

        // Ground leaf cluster functions
        function createGroundLeaves() {
            let groundLeaves = [];
            let trees = entities.filter(e => e.type === 'tree');

            // 3-5 leaves per tree base
            trees.forEach(tree => {
                let count = 3 + Math.floor(Math.random() * 3);
                for (let i = 0; i < count; i++) {
                    groundLeaves.push({
                        type: 'groundLeaf',
                        x: tree.x + (Math.random() - 0.5) * 120,
                        y: CAMERA_Y,
                        z: tree.z + (Math.random() - 0.5) * 60,
                        color: PALETTE.groundLeafColors[Math.floor(Math.random() * PALETTE.groundLeafColors.length)],
                        w: 2 + Math.random() * 3,
                        h: 1.5 + Math.random() * 2,
                    });
                }
            });

            // 20 scattered random ground leaves
            for (let i = 0; i < 20; i++) {
                groundLeaves.push({
                    type: 'groundLeaf',
                    x: (Math.random() - 0.5) * 2000,
                    y: CAMERA_Y,
                    z: Math.random() * MAX_Z,
                    color: PALETTE.groundLeafColors[Math.floor(Math.random() * PALETTE.groundLeafColors.length)],
                    w: 2 + Math.random() * 3,
                    h: 1.5 + Math.random() * 2,
                });
            }
            return groundLeaves;
        }

        function drawGroundLeaf(sx, sy, scale, leaf) {
            let w = Math.max(1, leaf.w * scale);
            let h = Math.max(1, leaf.h * scale);
            ctx.fillStyle = leaf.color;
            ctx.fillRect(Math.round(sx - w/2), Math.round(sy - h), Math.round(w), Math.round(h));
        }

        // ===== AUDIO SYSTEM =====
        let audioCtx = null;
        let audioInitialized = false;
        let audioPlaying = false;
        let audioChannels = {
            music: { gain: null, volume: 0.5, nodes: [] },
            wind: { gain: null, volume: 0.2, nodes: [] },
            birds: { gain: null, volume: 0.3, nodes: [] },
            footsteps: { gain: null, volume: 0.4, nodes: [] },
            sheep: { gain: null, volume: 0.08, nodes: [] }
        };

        function initAudio() {
            audioCtx = new (window.AudioContext || window.webkitAudioContext)();

            // Create gain nodes for each channel
            for (let key in audioChannels) {
                audioChannels[key].gain = audioCtx.createGain();
                audioChannels[key].gain.gain.value = audioChannels[key].volume;
                audioChannels[key].gain.connect(audioCtx.destination);
            }

            initLofiMusic();
            initWind();
            initBirds();
            initSheep();
            audioInitialized = true;
            audioPlaying = true;
        }

        // Music: Load and loop MP3 track
        async function initLofiMusic() {
            try {
                const resp = await fetch('morning-reset.mp3');
                const arr = await resp.arrayBuffer();
                const buf = await audioCtx.decodeAudioData(arr);
                const source = audioCtx.createBufferSource();
                source.buffer = buf;
                source.loop = true;
                source.connect(audioChannels.music.gain);
                source.start();
                audioChannels.music.nodes.push(source);
            } catch(e) { console.warn('Could not load music track:', e); }
        }

        // Wind: Brown noise through modulated low-pass filter
        function initWind() {
            const bufferSize = audioCtx.sampleRate * 2;
            const buffer = audioCtx.createBuffer(1, bufferSize, audioCtx.sampleRate);
            const data = buffer.getChannelData(0);

            let lastOut = 0;
            for (let i = 0; i < bufferSize; i++) {
                let white = Math.random() * 2 - 1;
                data[i] = (lastOut + (0.02 * white)) / 1.02;
                lastOut = data[i];
                data[i] *= 3.5;
            }

            const source = audioCtx.createBufferSource();
            source.buffer = buffer;
            source.loop = true;

            const filter = audioCtx.createBiquadFilter();
            filter.type = 'lowpass';
            filter.frequency.value = 400;
            filter.Q.value = 0.5;

            // LFO for gusting effect
            const lfo = audioCtx.createOscillator();
            const lfoGain = audioCtx.createGain();
            lfo.type = 'sine';
            lfo.frequency.value = 0.15;
            lfoGain.gain.value = 300;
            lfo.connect(lfoGain);
            lfoGain.connect(filter.frequency);
            lfo.start();

            const windGain = audioCtx.createGain();
            windGain.gain.value = 0.3;

            source.connect(filter);
            filter.connect(windGain);
            windGain.connect(audioChannels.wind.gain);

            source.start();
            audioChannels.wind.nodes.push(source, lfo);
        }

        // Birds: Periodic sine-wave chirps
        function initBirds() {
            function chirp() {
                if (!audioCtx || audioCtx.state === 'closed' || !audioPlaying) return;

                const now = audioCtx.currentTime;
                const noteCount = 2 + Math.floor(Math.random() * 3);

                for (let i = 0; i < noteCount; i++) {
                    const osc = audioCtx.createOscillator();
                    const oscGain = audioCtx.createGain();

                    osc.type = 'sine';
                    const baseFreq = 2000 + Math.random() * 2000;
                    const noteStart = now + i * 0.12;
                    const noteDuration = 0.06 + Math.random() * 0.06;

                    osc.frequency.setValueAtTime(baseFreq, noteStart);
                    osc.frequency.linearRampToValueAtTime(
                        baseFreq * (1 + (Math.random() - 0.5) * 0.3),
                        noteStart + noteDuration
                    );

                    oscGain.gain.setValueAtTime(0, noteStart);
                    oscGain.gain.linearRampToValueAtTime(0.06, noteStart + 0.01);
                    oscGain.gain.linearRampToValueAtTime(0, noteStart + noteDuration);

                    osc.connect(oscGain);
                    oscGain.connect(audioChannels.birds.gain);

                    osc.start(noteStart);
                    osc.stop(noteStart + noteDuration + 0.01);
                }

                setTimeout(chirp, 3000 + Math.random() * 5000);
            }

            setTimeout(chirp, 1000 + Math.random() * 2000);
        }

        // Sheep: Sample-based bleating from recorded audio files
        let sheepBuffers = [];
        async function initSheep() {
            const files = ['sheep.mp3', 'sheep2.mp3', 'sheep3.mp3'];
            for (const file of files) {
                try {
                    const resp = await fetch(file);
                    const arr = await resp.arrayBuffer();
                    const buf = await audioCtx.decodeAudioData(arr);
                    sheepBuffers.push(buf);
                } catch(e) { /* skip failed loads */ }
            }
            if (sheepBuffers.length > 0) {
                scheduleBaa();
            }
        }
        function scheduleBaa() {
            setTimeout(() => {
                if (!audioCtx || audioCtx.state === 'closed' || !audioPlaying) {
                    scheduleBaa();
                    return;
                }
                const buf = sheepBuffers[Math.floor(Math.random() * sheepBuffers.length)];
                const source = audioCtx.createBufferSource();
                source.buffer = buf;
                // Slight pitch variation for natural feel
                source.playbackRate.value = 0.9 + Math.random() * 0.2;
                source.connect(audioChannels.sheep.gain);
                source.start();
                scheduleBaa();
            }, 8000 + Math.random() * 12000);
        }

        // Footsteps: Noise bursts synced to walk phase
        let lastFootstepPhase = 0;
        function updateFootsteps() {
            if (!audioCtx || !audioInitialized || !audioPlaying) return;

            let walkPhase = time * 0.014;
            let currentPhase = Math.sin(walkPhase);

            if ((lastFootstepPhase >= 0 && currentPhase < 0) || (lastFootstepPhase <= 0 && currentPhase > 0)) {
                const now = audioCtx.currentTime;
                const sampleLen = Math.floor(audioCtx.sampleRate * 0.14);
                const buffer = audioCtx.createBuffer(1, sampleLen, audioCtx.sampleRate);
                const data = buffer.getChannelData(0);

                // Soft, muted envelope - like stepping on grass/dirt
                for (let i = 0; i < sampleLen; i++) {
                    const t = i / sampleLen;
                    // Slow attack, gradual decay for a soft thud
                    const attack = Math.min(1, t / 0.08);
                    const decay = Math.exp(-i / (sampleLen * 0.35));
                    const env = attack * decay;
                    data[i] = (Math.random() * 2 - 1) * env * 0.25;
                }

                const source = audioCtx.createBufferSource();
                source.buffer = buffer;

                // Very low cutoff for muffled ground-step sound
                const filter = audioCtx.createBiquadFilter();
                filter.type = 'lowpass';
                filter.frequency.value = 180 + Math.random() * 80;
                filter.Q.value = 0.3;

                // Second filter pass for extra muffling
                const filter2 = audioCtx.createBiquadFilter();
                filter2.type = 'lowpass';
                filter2.frequency.value = 350;
                filter2.Q.value = 0.4;

                source.connect(filter);
                filter.connect(filter2);
                filter2.connect(audioChannels.footsteps.gain);

                source.start(now);
            }

            lastFootstepPhase = currentPhase;
        }

        // Audio UI logic
        function setupAudioUI() {
            const toggleBtn = document.getElementById('audio-toggle');
            const panel = document.getElementById('audio-panel');

            toggleBtn.addEventListener('click', () => {
                if (!audioInitialized) {
                    initAudio();
                    toggleBtn.textContent = '\u266B Sound';
                }
                panel.classList.toggle('open');
            });

            document.querySelectorAll('.audio-slider input[type="range"]').forEach(slider => {
                slider.addEventListener('input', (e) => {
                    const channel = e.target.dataset.channel;
                    const value = e.target.value / 100;
                    audioChannels[channel].volume = value;
                    if (audioChannels[channel].gain) {
                        audioChannels[channel].gain.gain.value = value;
                    }
                });
            });
        }

        function init() {
            resize(); window.addEventListener('resize', resize);
            const TREE_COUNT = 20;
            for (let i=0; i<TREE_COUNT; i++) {
                entities.push({
                    type:'tree',
                    x: getRandomTreeX(),
                    y:CAMERA_Y,
                    z: (i / TREE_COUNT) * MAX_Z + Math.random() * (MAX_Z / TREE_COUNT),
                    variant:Math.floor(Math.random()*6),
                    hScale:0.8+Math.random()*0.7
                });
            }
            for (let i=0; i<300; i++) {
                let gx=(Math.random()-0.5)*2000, gz=Math.random()*MAX_Z;
                entities.push({ type:'grass', x:gx, y:CAMERA_Y, z:gz, variant:getGrassVariant(gx,gz) });
            }
            for (let i=0; i<80; i++) {
                let leaf={type:'leaf'}; resetLeaf(leaf); leaf.y+=Math.random()*100; entities.push(leaf);
            }

            // Create ground leaf clusters
            let groundLeaves = createGroundLeaves();
            groundLeaves.forEach(gl => entities.push(gl));

            for (let i=0; i<6; i++) {
                clouds.push({ x:Math.random()*canvas.width, y:Math.random()*(HORIZON-50), w:40+Math.random()*80, h:15+Math.random()*20, speed:0.02+Math.random()*0.03 });
            }
            for (let i=0; i<5; i++) {
                birds.push({ x:Math.random()*canvas.width, y:10+Math.random()*(HORIZON/2), offset:Math.random()*100 });
            }

            setupAudioUI();
            requestAnimationFrame(loop);
        }

        function drawRect(x,y,w,h,color) { ctx.fillStyle=color; ctx.fillRect(Math.round(x),Math.round(y),Math.round(w),Math.round(h)); }

        function drawBackground() {
            let bandH=HORIZON/PALETTE.skyBands.length;
            PALETTE.skyBands.forEach((color,i)=>{ drawRect(0,i*bandH,canvas.width,bandH+2,color); });
            drawRect(canvas.width*0.75, HORIZON*0.15, 28, 28, PALETTE.sun);
            drawRect(canvas.width*0.75-2, HORIZON*0.15+4, 32, 20, PALETTE.sun);
            drawRect(canvas.width*0.75+4, HORIZON*0.15-2, 20, 32, PALETTE.sun);

            clouds.forEach(c => {
                c.x+=c.speed; if (c.x>canvas.width+c.w) c.x=-c.w;
                drawRect(c.x+c.w*0.05,c.y+c.h*0.4,c.w*0.9,c.h*0.7,PALETTE.cloudShadow);
                drawRect(c.x,c.y,c.w,c.h,PALETTE.cloudBase);
                drawRect(c.x+c.w*0.15,c.y-c.h*0.3,c.w*0.5,c.h*0.8,PALETTE.cloudBase);
                drawRect(c.x+c.w*0.4,c.y-c.h*0.5,c.w*0.4,c.h*1.1,PALETTE.cloudBase);
                drawRect(c.x+2,c.y+2,c.w*0.9,c.h*0.3,PALETTE.cloudLight);
                drawRect(c.x+c.w*0.15+2,c.y-c.h*0.3+2,c.w*0.4,c.h*0.3,PALETTE.cloudLight);
                drawRect(c.x+c.w*0.4+2,c.y-c.h*0.5+2,c.w*0.3,c.h*0.3,PALETTE.cloudLight);
            });

            // FAR HILLS
            mountains.far.forEach(m => {
                fillHillWithVerticalFade(m, PALETTE.hillFar, HAZE_FAR);
                drawHillPatches(m, PALETTE.hillFarLight, PALETTE.hillFarShadow, PALETTE.hillFarLight, HAZE_FAR);
                drawTreeLine(m, PALETTE.hillFarTree, 0.55, 3, HAZE_FAR);
            });

            // MID HILLS
            mountains.mid.forEach(m => {
                fillHillWithVerticalFade(m, PALETTE.hillMid, HAZE_MID);
                drawHillPatches(m, PALETTE.hillMidLight, PALETTE.hillMidShadow, PALETTE.hillMidField, HAZE_MID);
                drawHedgeRow(m, PALETTE.hillMidShadow, HAZE_MID);
                drawTreeLine(m, PALETTE.hillMidTree, 0.45, 4, HAZE_MID);
            });

            // NEAR HILLS
            mountains.near.forEach(m => {
                fillHillWithVerticalFade(m, PALETTE.hillNear, HAZE_NEAR);
                drawHillPatches(m, PALETTE.hillNearLight, PALETTE.hillNearShadow, PALETTE.hillNearField, HAZE_NEAR);
                drawHedgeRow(m, PALETTE.hillNearDark, HAZE_NEAR);
                drawTreeLine(m, PALETTE.hillNearTree, 0.35, 5, HAZE_NEAR);
            });

            // HORIZON HAZE BAND
            let hazeHex = rgbToHex(PALETTE.horizonHaze.r, PALETTE.horizonHaze.g, PALETTE.horizonHaze.b);
            let hazeBandH = 8;
            for (let i = 0; i < hazeBandH; i++) {
                let t = 1.0 - (i / hazeBandH);
                t = t * t * 0.3;
                ctx.globalAlpha = t;
                ctx.fillStyle = hazeHex;
                ctx.fillRect(0, HORIZON - hazeBandH + i, canvas.width, 1);
            }
            ctx.globalAlpha = 1.0;

            // Sheep
            sheeps.forEach(s => {
                s.x+=s.speed; if (s.x>canvas.width+10) s.x=-10; if (s.x<-10) s.x=canvas.width+10;
                let isEating=Math.sin(time*0.002+s.offset)>0.6;
                let sx=Math.round(s.x), sy=Math.round(s.y);
                ctx.fillStyle=PALETTE.cloudLight; ctx.fillRect(sx,sy,3,2); ctx.fillRect(sx+1,sy-1,1,1);
                ctx.fillStyle=PALETTE.treeTrunkDark; ctx.fillRect(sx,sy+2,1,1); ctx.fillRect(sx+2,sy+2,1,1);
                ctx.fillRect(s.speed>0?sx+3:sx-1, sy+(isEating?1:0), 1, 1);
            });

            birds.forEach(b => {
                b.x+=0.15; b.y+=Math.sin(time*0.0015+b.offset)*0.1; if (b.x>canvas.width+20) b.x=-20;
                ctx.fillStyle='#2c3e50';
                ctx.fillRect(Math.round(b.x),Math.round(b.y),2,1);
                ctx.fillRect(Math.round(b.x-2),Math.round(b.y-2),2,2);
                ctx.fillRect(Math.round(b.x+2),Math.round(b.y-2),2,2);
            });
        }

        function drawGround() {
            let startY=Math.floor(HORIZON)+1;
            ctx.fillStyle=PALETTE.grassLight; ctx.fillRect(0,startY,canvas.width,canvas.height-startY);
            for (let y=startY; y<canvas.height; y++) {
                let z=(FOV*CAMERA_Y)/(y-HORIZON); if (z>MAX_Z) continue;
                let scale=FOV/(FOV+z), actualZ=z+cameraZ, zIndex=Math.floor(actualZ/15);
                ctx.fillStyle=PALETTE.grassDark;
                let ns=3+(Math.abs(Math.sin(zIndex*0.77))*6);
                for(let i=0;i<ns;i++) { let hx=Math.sin(zIndex*0.11+i*1.5)*10000, wx=(Math.abs(hx)%6000)-3000;
                    ctx.fillRect(cx+wx*scale,y,(150+(Math.abs(Math.cos(zIndex+i))*250))*scale,1); }
                ctx.fillStyle=PALETTE.grassDarker;
                let nd=2+(Math.abs(Math.cos(zIndex*1.3))*4);
                for(let i=0;i<nd;i++) { let hx=Math.cos(zIndex*0.23+i*2.1)*10000, wx=(Math.abs(hx)%6000)-3000;
                    ctx.fillRect(cx+wx*scale,y,(80+(Math.abs(Math.sin(zIndex-i))*150))*scale,1); }
            }
        }

        function drawGrass(sx,sy,scale,variant) {
            let isTall=variant>=8, w=(isTall?5:3+(variant%3))*scale, h=(isTall?20+(variant%2)*10:8+(variant%4)*2)*scale;
            let col=PALETTE.grassShades[variant%PALETTE.grassShades.length], darkCol=PALETTE.grassShades[(variant+2)%PALETTE.grassShades.length];
            drawRect(sx-w/2,sy-h,w,h,darkCol); drawRect(sx-w/4,sy-h*0.8,w/2,h*0.8,col);
            if (isTall) { drawRect(sx-w,sy-h*0.9,2*scale,h*0.7,darkCol); drawRect(sx+w*0.5,sy-h*1.1,2*scale,h*0.8,col); drawRect(sx+w*0.5+2*scale,sy-h*1.1,3*scale,2*scale,col); }
            else { drawRect(sx+w/4,sy-h*1.2,1.5*scale,h*0.6,col); }
        }

        function getTreeHazeFactor(relZ) { return Math.max(0, Math.min(1, relZ/MAX_Z))*0.4; }

        function getPineBlocks(sx,sy,scale,wind,trunkH,variant) {
            let blocks=[], tiers=4+(variant%2);
            for (let i=0; i<tiers; i++) {
                let tw=(70-i*15)*scale, th=28*scale, ty=sy-trunkH+(5-i*20)*scale, wo=wind*(0.2+i*0.15);
                blocks.push({x:sx-tw/2+wo,y:ty,w:tw,h:th});
                blocks.push({x:sx-tw/2+wo-2*scale,y:ty+th*0.3,w:2*scale,h:th*0.7});
                blocks.push({x:sx+tw/2+wo,y:ty+th*0.3,w:2*scale,h:th*0.7});
                blocks.push({x:sx-tw/2+wo-5*scale,y:ty+th*0.5,w:3*scale,h:th*0.4});
                blocks.push({x:sx+tw/2+wo+2*scale,y:ty+th*0.5,w:3*scale,h:th*0.4});
            }
            return blocks;
        }

        function getOakBlocks(sx,sy,scale,wind,trunkH) {
            let cy=sy-trunkH-20*scale, wo=wind*0.4;
            return [{x:0,y:0,w:90,h:70},{x:-25,y:-10,w:60,h:50},{x:25,y:-10,w:60,h:50},
                {x:0,y:-30,w:70,h:50},{x:-35,y:15,w:40,h:40},{x:35,y:15,w:40,h:40},
                {x:-40,y:-20,w:25,h:25},{x:40,y:-20,w:25,h:25},{x:-20,y:-45,w:30,h:25},
                {x:20,y:-45,w:30,h:25},{x:-45,y:5,w:20,h:20},{x:45,y:5,w:20,h:20}
            ].map(b=>({ x:sx+b.x*scale+wo-(b.w*scale)/2, y:cy+b.y*scale, w:b.w*scale, h:b.h*scale }));
        }

        function drawTree(sx,sy,scale,origX,origZ,variant,hScale,relZ) {
            scale*=1.8*hScale;
            let wind=Math.sin(time*0.001+origX*0.1+origZ*0.05)*6*scale;
            let trunkW=Math.max(3,16*scale), trunkH=(90+(Math.abs(Math.round(origX))%40))*scale;
            let isPine=(variant%2===0);
            let hazeFactor=getTreeHazeFactor(relZ), hazeRgb=PALETTE.hazeColor;
            let canopyBlocks=isPine ? getPineBlocks(sx,sy,scale,wind,trunkH,variant) : getOakBlocks(sx,sy,scale,wind,trunkH);

            let outlinePad=Math.max(1,Math.round(2*scale));
            let shadowOffX=Math.max(1,Math.round(3*scale));
            let shadowOffY=Math.max(1,Math.round(3*scale));
            let rimWidth=Math.max(1,Math.round(1.5*scale));

            ctx.fillStyle=PALETTE.treeShadowDrop;
            canopyBlocks.forEach(b=>{ ctx.fillRect(Math.round(b.x+shadowOffX),Math.round(b.y+shadowOffY),Math.round(b.w),Math.round(b.h)); });

            let outlineColor=hazeFactor>0?lerpColor(PALETTE.treeOutline,hazeRgb,hazeFactor*0.8):PALETTE.treeOutline;
            ctx.fillStyle=outlineColor;
            canopyBlocks.forEach(b=>{ ctx.fillRect(Math.round(b.x-outlinePad),Math.round(b.y-outlinePad),Math.round(b.w+outlinePad*2),Math.round(b.h+outlinePad*2)); });

            let trunkCol=hazeFactor>0?lerpColor(PALETTE.treeTrunk,hazeRgb,hazeFactor):PALETTE.treeTrunk;
            let trunkDarkCol=hazeFactor>0?lerpColor(PALETTE.treeTrunkDark,hazeRgb,hazeFactor):PALETTE.treeTrunkDark;
            drawRect(sx-trunkW/2,sy-trunkH,trunkW/2,trunkH,trunkDarkCol);
            drawRect(sx,sy-trunkH,trunkW/2,trunkH,trunkCol);
            drawRect(sx-trunkW*0.2,sy-trunkH*0.8,2*scale,trunkH*0.6,trunkDarkCol);

            if (isPine) {
                let tiers=4+(variant%2);
                for (let i=0; i<tiers; i++) {
                    let tw=(70-i*15)*scale, th=28*scale, ty=sy-trunkH+(5-i*20)*scale, wo=wind*(0.2+i*0.15);
                    let bc=lerpColor(PALETTE.pineLeavesBase[i%3],hazeRgb,hazeFactor);
                    let hc=lerpColor(PALETTE.pineLeavesHigh[i%3],hazeRgb,hazeFactor);
                    let sc=lerpColor(PALETTE.pineLeavesShadow[i%3],hazeRgb,hazeFactor);
                    drawRect(sx-tw/2+wo,ty+th*0.4,tw,th*0.6,sc);
                    drawRect(sx-tw/2+wo,ty,tw/2,th*0.8,bc);
                    drawRect(sx+wo,ty,tw/2,th*0.8,hc);
                    drawRect(sx-tw/2+wo-2*scale,ty+th*0.3,2*scale,th*0.7,bc);
                    drawRect(sx+tw/2+wo,ty+th*0.3,2*scale,th*0.7,hc);
                    drawRect(sx-tw/2+wo-5*scale,ty+th*0.5,3*scale,th*0.4,bc);
                    drawRect(sx+tw/2+wo+2*scale,ty+th*0.5,3*scale,th*0.4,hc);
                    drawRect(sx-tw/3+wo,ty+th,6*scale,4*scale,sc);
                    drawRect(sx+tw/4+wo,ty+th,6*scale,4*scale,sc);
                }
            } else {
                let cy=sy-trunkH-20*scale, wo=wind*0.4;
                [{x:0,y:0,w:90,h:70},{x:-25,y:-10,w:60,h:50},{x:25,y:-10,w:60,h:50},
                 {x:0,y:-30,w:70,h:50},{x:-35,y:15,w:40,h:40},{x:35,y:15,w:40,h:40},
                 {x:-40,y:-20,w:25,h:25},{x:40,y:-20,w:25,h:25},{x:-20,y:-45,w:30,h:25},
                 {x:20,y:-45,w:30,h:25},{x:-45,y:5,w:20,h:20},{x:45,y:5,w:20,h:20}
                ].forEach(b => {
                    let bw=b.w*scale, bh=b.h*scale, bx=sx+b.x*scale+wo, by=cy+b.y*scale;
                    let bc=lerpColor(PALETTE.oakLeavesBase[variant%3],hazeRgb,hazeFactor);
                    let hc=lerpColor(PALETTE.oakLeavesHigh[variant%3],hazeRgb,hazeFactor);
                    let sc=lerpColor(PALETTE.oakLeavesShadow[variant%3],hazeRgb,hazeFactor);
                    drawRect(bx-bw/2,by+bh*0.2,bw,bh*0.8,sc);
                    drawRect(bx-bw/2,by,bw/2,bh*0.7,bc);
                    drawRect(bx,by,bw/2,bh*0.7,hc);
                    drawRect(bx-bw/2-2*scale,by+bh*0.2,2*scale,bh*0.5,bc);
                    drawRect(bx+bw/2,by+bh*0.2,2*scale,bh*0.5,hc);
                });
            }

            let rimColor=lerpColor(PALETTE.rimLight,hazeRgb,hazeFactor*0.5);
            let rimBright=lerpColor(PALETTE.rimLightBright,hazeRgb,hazeFactor*0.5);
            ctx.globalAlpha=Math.max(0.15, 1.0-hazeFactor*1.5);
            canopyBlocks.forEach(b => {
                drawRect(b.x+b.w-rimWidth, b.y, rimWidth, b.h, rimColor);
                drawRect(b.x, b.y, b.w, rimWidth, rimColor);
                drawRect(b.x+b.w-rimWidth*2, b.y, rimWidth*2, rimWidth, rimBright);
            });
            ctx.globalAlpha=1.0;
        }

        function drawLeaf(sx,sy,scale,leaf) {
            let w=Math.max(1,(leaf.treeType===0?4:7)*scale), h=Math.max(1,(leaf.treeType===0?10:7)*scale);
            drawRect(sx,sy,w,h,leaf.color);
        }

        function drawDog(charX,charY,charScale,walkPhase) {
            let bob=Math.abs(Math.sin(walkPhase*1.4))*2.5, legSwing=Math.sin(walkPhase*1.4);
            let dogX=charX+18*charScale, dogY=charY-2*charScale;
            let d=(x,y,w,h,color)=>{ drawRect(dogX+x*charScale,dogY+y*charScale-bob,w*charScale,h*charScale,color); };

            ctx.fillStyle='rgba(0,0,0,0.25)';
            ctx.fillRect(Math.round(dogX-4*charScale),Math.round(dogY+12*charScale),Math.round(10*charScale),Math.round(3*charScale));

            let tailWag=Math.sin(time*0.015)*3;
            d(-1+tailWag,8,2,4,'#A0693E'); d(-1.5+tailWag*1.3,11,2,3,'#B8804A'); d(-2+tailWag*1.5,13,2,2,'#D4C4A8');

            let lbl=legSwing>0?-legSwing*2.5:0, rbl=legSwing<0?legSwing*2.5:0;
            drawRect(dogX-4*charScale,dogY+(6+lbl)*charScale-bob,3*charScale,(5-lbl)*charScale,'#7A4E2D');
            drawRect(dogX+2*charScale,dogY+(6+rbl)*charScale-bob,3*charScale,(5-rbl)*charScale,'#8B5E3C');
            d(-4,10.5,3,1,'#D4C4A8'); d(2,10.5,3,1,'#D4C4A8');

            d(-4,0,10,8,'#A0693E'); d(-3,-1,8,2,'#B8804A'); d(-4,7,10,1,'#7A4E2D');
            d(-2,1,6,2,'#B8804A'); d(-1,3,4,2,'#A0693E');

            let lfl=legSwing<0?legSwing*2.5:0, rfl=legSwing>0?-legSwing*2.5:0;
            drawRect(dogX-4*charScale,dogY+(-3+lfl)*charScale-bob,2*charScale,(4-lfl)*charScale,'#7A4E2D');
            drawRect(dogX+4*charScale,dogY+(-3+rfl)*charScale-bob,2*charScale,(4-rfl)*charScale,'#8B5E3C');

            let headLook=Math.sin(time*0.0018), isLooking=Math.abs(headLook)>0.7, lookOffset=isLooking?headLook*2.5:0;
            d(-3+lookOffset,-7,8,5,'#A0693E'); d(-2+lookOffset,-8,6,3,'#B8804A'); d(-1+lookOffset,-6,4,3,'#A0693E');
            let earBounce=Math.sin(walkPhase*1.4)*0.5;
            d(-5+lookOffset,-7+earBounce,3,4,'#7A4E2D'); d(-5+lookOffset,-6+earBounce,2,2,'#6B3F22');
            d(4+lookOffset,-7+earBounce,3,4,'#7A4E2D'); d(5+lookOffset,-6+earBounce,2,2,'#6B3F22');
            if (isLooking) {
                if (headLook>0) { d(5+lookOffset,-5,2,2,'#B8804A'); d(6+lookOffset,-5,1,1,'#3D2517'); d(4+lookOffset,-7,1,1,'#1A0E08'); }
                else { d(-5+lookOffset,-5,2,2,'#B8804A'); d(-5+lookOffset,-5,1,1,'#3D2517'); d(-3+lookOffset,-7,1,1,'#1A0E08'); }
            }
            d(-3+lookOffset,-3,8,1,'#CC3333'); d(1+lookOffset,-3,1,2,'#FFD700');
        }

        function drawCharacter() {
            let charX=cx, charY=canvas.height-20, charScale=1.2;
            let walkPhase=time*0.0056925, bob=Math.abs(Math.sin(walkPhase))*4, legSwing=Math.sin(walkPhase);
            let p=(x,y,w,h,color)=>{ drawRect(charX+x*charScale,charY+y*charScale-bob,w*charScale,h*charScale,color); };

            ctx.fillStyle='rgba(0,0,0,0.3)';
            ctx.fillRect(Math.round(charX-12*charScale),Math.round(charY+12*charScale),Math.round(24*charScale),Math.round(4*charScale));

            let llY=legSwing>0?-legSwing*5:0;
            drawRect(charX-6*charScale,charY+5*charScale-bob-llY,5*charScale,(10+llY)*charScale,'#1E3D59');
            let rlY=legSwing<0?legSwing*5:0;
            drawRect(charX+1*charScale,charY+5*charScale-bob-rlY,5*charScale,(10+rlY)*charScale,'#1E3D59');

            p(-9,-12,18,18,'#6B4226'); p(-8,-11,16,16,'#8B5A3C'); p(-7,-10,14,14,'#7A4C30');
            p(-1,-9,2,12,'#5A3520'); p(-9,-14,18,3,'#5A3520'); p(-8,-13,16,1,'#6B4226');
            p(-9,6,18,2,'#5A3520'); p(-9,-4,18,1,'#5A3520'); p(-9,1,18,1,'#5A3520');
            p(-6,-3,12,6,'#7A4C30'); p(-5,-2,10,4,'#8B5A3C'); p(-5,-3,10,1,'#5A3520');
            p(-11,-2,3,7,'#6B4226'); p(8,-2,3,7,'#6B4226');
            p(8,-4,3,5,'#4A7A8C'); p(8,-5,3,2,'#5A8A9C');
            p(-10,-18,20,4,'#3D6B4F'); p(-9,-17,18,2,'#4D7B5F'); p(-10,-18,20,1,'#2D5B3F');
            p(-7,-18,2,4,'#5A3520'); p(5,-18,2,4,'#5A3520');
            p(-9,-12,3,14,'#5A3520'); p(6,-12,3,14,'#5A3520');
            p(-8,-11,1,12,'#6B4226'); p(8,-11,1,12,'#6B4226');

            p(-5,-24,10,10,'#f5cba7'); p(-6,-26,12,8,'#2c1e16');
            p(-5,-25,10,6,'#3a2920'); p(-4,-24,8,4,'#2c1e16');
            p(-7,-22,2,3,'#f5cba7'); p(5,-22,2,3,'#f5cba7');

            let laY=legSwing*4;
            drawRect(charX-12*charScale,charY-8*charScale-bob+laY,3*charScale,10*charScale,'#d35400');
            let raY=-legSwing*4;
            drawRect(charX+9*charScale,charY-8*charScale-bob+raY,3*charScale,10*charScale,'#d35400');

            drawDog(charX,charY,charScale,walkPhase);
        }

        function loop(timestamp) {
            time+=3; cameraZ+=SPEED;

            // Update footsteps audio
            updateFootsteps();

            entities.forEach(e => {
                if (e.type==='leaf') { e.y+=e.speedY; e.x+=Math.sin(time*0.001+e.z)*0.5; }
                let relZ=e.z-cameraZ;
                if (relZ<1||(e.type==='leaf'&&e.y>CAMERA_Y)) {
                    if (e.type==='tree') { e.z+=MAX_Z; e.x=getRandomTreeX(); e.hScale=0.8+Math.random()*0.7; }
                    else if (e.type==='grass') { e.z+=MAX_Z; e.x=(Math.random()-0.5)*2000; e.variant=getGrassVariant(e.x,e.z); }
                    else if (e.type==='leaf') { resetLeaf(e); relZ=e.z-cameraZ; }
                    else if (e.type==='groundLeaf') {
                        e.z+=MAX_Z;
                        e.x=(Math.random()-0.5)*2000;
                        e.color=PALETTE.groundLeafColors[Math.floor(Math.random()*PALETTE.groundLeafColors.length)];
                    }
                }
                e.relZ=relZ;
            });
            entities.sort((a,b)=>b.relZ-a.relZ);
            ctx.clearRect(0,0,canvas.width,canvas.height);
            drawBackground(); drawGround();
            entities.forEach(e => {
                if (e.relZ>MAX_Z) return;
                let scale=FOV/(FOV+e.relZ), sx=cx+e.x*scale, sy=HORIZON+(e.y!==undefined?e.y:CAMERA_Y)*scale;
                if (e.type==='tree') drawTree(sx,sy,scale,e.x,e.z,e.variant,e.hScale,e.relZ);
                if (e.type==='leaf') drawLeaf(sx,sy,scale,e);
                if (e.type==='grass') drawGrass(sx,sy,scale,e.variant);
                if (e.type==='groundLeaf') drawGroundLeaf(sx,sy,scale,e);
            });
            drawCharacter();
            requestAnimationFrame(loop);
        }

        init();
    </script>
</body>
</html>
